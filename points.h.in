/// points \\\

#define DEBUG

#ifndef ulong
	#define ulong unsigned long
#endif

#ifndef ullong
	#define ullong unsigned long long 
#endif

/**
atherpoint `FIFO`s
 * with a singular reader, that is the `lbb`
 * 
 * writers can connect to the atherpoint syncronously 
 * and query real time updates on the values , operations
 * that are used to create/modify these values.
 * 
 * that is done mainly by kurling the lbb between two or more
 * points. 
 * 
**/
#ifndef points
	#define __ap_name "atherpoint"
    #define __nai_name "native_ather_interface"
	/**
	 * nai is a union of structs to indicate which current
	 * level is provided, since `__nai` is a union we will
	 * use a concept called common initial sequence ( cis )
	 * for the structs a_i*, 
	 * 
	cis :: prepend : `__`
	 * 
	 */

	#include "../probe.h"
	#define sp_network htons( 9999 )
	#define __n_glo_socket "3490"  // the global conf port
	#define __q_len 10   // queue size for connections

    /**
    iterable( node & mount path )
    `a_inmp` :: struct i-nodenum,mountpath
    **/  
    struct a_inmp {
        long inn; 
                // node number
        char imp[max_path]; 
                // mount path
    };
    /**
    iterable( soket ) :: k_types : iterable
    **/
    struct a_isok {
        long __inn; 
                // cis
        char __imp[max_path]; 
                // cis

        unsigned isv; 
                // socket value
        struct sockaddr_storage isa;
                // binded socket address
        int isp;
                // socket port
    };
    /**
    iterable( dynamic naming system )
    `a_idns` :: struct domain name system
    **/
    struct a_idns {
        long __inn; 
                // cis
        char __imp[max_path]; 
                // cis

        unsigned __isv; 
                // cis
        struct sockaddr_storage isa; 
                // cis
        int __isp; 
                // cis

        char ids[max_str]; 
                // sub domain
        char idn[max_str]; 
                // domain name
        char idt[max_str]; 
                // top level domain
    };
    /**
    iterable( blockchain native address )
     *
     * for any great blockchain to be acceptable
     * it must do a task to register said blocks
     * 
     **the task could be simple or complex.
     **as long as it's one particular task
     **or a sequence of tasks. changable or not
     * depening on the configuration params.
     *
    `a_ibna` :: struct blockchain native address
    **/
    struct a_ibna {
        long __inn; 
                // cis
        char __imp[max_path]; 
                // cis

        unsigned __isv; 
                // cis
        struct sockaddr_storage isa; 
                // cis
        int __isp; 
                // cis

        char __ids[max_str];
                 // cis
        char __idn[max_str];
                 // cis
        char __idt[max_str];
                 // cis

        char ibi[max_str]; 
                // blockchain identifier
        char iba[max_str];
                // blockchain address ( public key )
    };
    /**
    `__nai` :: union that defines different interfaces
     * for the different levels & { 0...3 } web types
    **/
    union __nai {
        struct a_inmp __mach; 
                // machine
        struct a_isok __loch; 
                // local
        struct a_idns __gloh; 
                // global
        struct a_ibna __unih; 
                // universal
    };
    #define nai union __nai
    static nai net_interface;

  
    /**
    returns ( indicator ) { fills struct `n_*interface` }
     *
    **/
    nai native_interface( int level );
    int mac_interface( struct a_inmp n_mach );
    int loc_interface( struct a_isok n_loch );
    int glo_interface( struct a_idns n_gloh );
    int uni_interface( struct a_ibna n_unih );

	enum __io_types {
		__io_r = 1,
		__io_ws
	};

	struct p_io {
		ulong io_pfd;
				// a paticular file descriptor
		long io_pid;
				// the initating process id
		enum __io_types io_type;
				// the IO type, mainly will be writers
	};
	#define __size_p_io sizeof( struct p_io )
	#define point_io struct p_io

	struct p_st {
		struct stat p_stat;
				// the FIFO stat in the filesystem
		point_io p_known;
				// the point reader&executor
		point_io p_annon;
				  // annonymus point request
	};
	#define __size_p_st sizeof( struct point_st )
	#define point_st struct p_st

	struct p_si {
		point_st pst;
				// the ather point structure
		int plvl;
				// the level associated with the structure
		void *p_i;
				// can && should be casted to a { nai } reference
	};
	#define __size_p_si sizeof( struct p_si )
	#define __size_p __size_p_si
	#define point_si struct p_si

	static char ap_name[8];
	static point_si ap; 

	#define point_descriptors() \
		( ap.st.p_lbb.io_pfd > 0 ) || ( ap.st.p_annon.io_pfd > 0 ) ? 1 : 0 

	#define point_exists() __file_exsits( __ap_name )
	#define make_point atherpoint

	#define is_reader ap.st.p_annon.io_pid == 0
	#define is_writer ap.st.p_known.io_pid == 0
	
	#define p_writer() int _w_res = 0;\
		do { ap.st.p_annon.io_pfd = _ap_w_entry(); _w_res = ( ap.st.p_annon.io_pfd != 0 )  } while( 0 )

	#define p_reader() int _r_res = 0;\
		do { ap.st.p_known.io_pfd = _ap_r_entry(); _r_res = ( ap.st.p_known.io_pfd != 0 ) } while( 0 )

	extern int atherpoint( char ap_ref[8] );
	int process_entry( char *p_entry , int pe_type );
	int app_engine( point_io *engint );
	int socket_execute( point_io *sexec );
	extern int applier();
#endif
#ifndef atherpoint
    int atherpoint( char ap_ref[8] ) {
        memmove( ap_name , ap_ref , 8 );
        #ifdef DEBUG
            printf( "@point :: ref = %s\n" , ap_name );
        #endif
        memset( &ap , 0 , __size_p_si );
        #ifdef DEBUG
            printf( "@point :: checking for atherpoint\n" );
        #endif
        if ( !__ap_fifo( ap_name , &ap.st.p_stat ) ) {
            #ifdef DEBUG
                printf( "@point :: no atherpoint found, attempting to create one\n" );
            #endif
            if ( !__ap_make() ) {
                #ifdef DEBUG
                    printf( "@point :: unable to create atherpoint\n" );
                #endif
                return -2;
            }
        }
        return 0;
    }
#endif

    /*  
    @-PROTOCOL  
     #Morles
                */ 

#ifndef ap_protocol
    #define ap_protocol "@protocol"
    #define ap_mor "@mor"
    #define ap_les "@les"
    #define BACKLOG @__sa__m@
    #define MAX_STR @__sa__npr@
    #define SELECTOR_BYTES @__sa__m@
    #define PROTOCOL_STYLE "axA-E@N#A{E}"
    #define PROTOCOL_LINE "aAedNME\0"
    #define ATHER_SERVICE "0xather"
    #define PORT_ACCEPT "9999"
    #define X_NODEF &"\0"


    struct __protocol {
        uchar _diff; // 1 byte
        ulong _len , _size , _select; // 2bytes each
        uchar *_name , *_bin , *_type; // string
        ullong _selector; // 8 bytes
    } ;

    #define MOR __mor()
    #define LES les__()

	// linux - #man getaddrinfo
    // GNU LICENSE
    // getaddrinfo( node , serv , hints , res )
    // struct addrinfo {
    //    int              ai_flags;
    //    int              ai_family;
    //    int              ai_socktype;
    //    int              ai_protocol;
    //    socklen_t        ai_addrlen;
    //    struct sockaddr *ai_addr;
    //    char            *ai_canonname;
    //    struct addrinfo *ai_next;
	// };
    #define pathify( node , serv , __typeproto , __override , ... ) \
        __pathify( node , serv , ( ( typeproto * ) __typeproto  ) , __override , ##__VA_ARGS__ )

    static const char protocol_example[49] = "3xather-pub*\\1@4k#default\\{#}";

    void *__ip( char *str , struct sockaddr *_ ) {
        if ( _ -> sa_family == A_INET ) {
            struct sockaddr_in *ipv4 = ( struct sockaddr_in * )_;
            if ( inet_ntop( AF_INET , &( ipv4 -> sin_addr ) , str , INET_ADDRSTRLEN ) != NULL ) {
                return &( ipv4 -> sin_addr );
            }
            return X_NODEF;
        }
        struct sockaddr_in6 *ipv6 = ( struct sockaddr_in6 * )_;
        if ( inet_ntop( AF_INET , &( ipv6 -> sin6_addr ) , str , INET6_ADDRSTRLEN ) != NULL ) {
            return &( ipv6 -> sin6_addr );
        }
        return X_NODEF;
    }

    int get_listener_socket( void ) {
        int _listener;
        int yes=1;
        int rv;
        struct addrinfo hints, *les_info, *p;
        memset( &hints , 0 , sizeof hints );
        hints.ai_family = AF_UNSPEC;
        hints.ai_socktype = SOCK_STREAM;
        hints.ai_flags = AI_PASSIVE;

        if ( ( rv = getaddrinfo( NULL , PORT_ACCEPT , &hints , &les_info ) ) != 0 ) {
            fprintf( stderr , " getaddr info : %s\n" , gai_strerror( rv ) );
            return 1;
        }
        for( p = les_info; p != NULL; p = p -> ai_next ) {
            _listener = socket( p -> ai_family , p -> ai_socktype , p -> ai_protocol );
            if ( _listener < 0 ) {
                continue;
            }
            // remove "addr in use" bs
            setsockopt( _listener , SOL_SOCKET , SO_REUSEADDR , &yes , sizeof( int ) );
            if ( bind( _listener , p -> ai_addr , p -> ai_addrlen ) < 0 ) {
                continue;
            }
            break;
        }

        freeaddrinfo( les_info );
        if ( p == NULL ) {
            return -1;
        }

        return _listener;
    }

    void add_to_pfds( struct pollfd *pfds[] , int newfd , int *fd_count , int *fd_size ) {
        // check for memory allocation
        if ( *fd_count == *fd_size ) {
            *fd_size += 2;
            *pfds = realloc( *pfds , sizeof( **pfds ) * ( *fd_size ) );
        }
        (*pfds)[*fd_count].fd = newfd;
        (*pfds)[*fd_count].events = POLLIN;
        (*fd_count)++;
    }

    void del_from_pfds( struct pollfd pfds[] , int i , int *fd_count ) {
        pfds[i] = pfds[*fd_count-1];
        (*fd_count)--;
    }

    int LES__( void ) {
        int listener;
        int newfd;
        struct sockaddr_storage remoteaddr;
        socklen_t addrlen;
        char buf[MAX_STR];
        char remoteIP[INET6_ADDRSTRLEN];

        int fd_count = 0;
        int fd_size = 5;
        struct pollfd *pfds = malloc( sizeof *pfds * fd_size );

        listener = get_listener_socket();
        if ( listener == -1 ) {
            fprintf( stderr , "error , ather cannot les.\n" );
            return 2;
        }

        pfds[0].fd = listener;
        pfds[0].events = POLLIN;

        for(;;) {
            int poll_count = poll( pfds , fd_count , -1 );
            if ( poll_count == -1 ) {
                perror("poll");
                return 2;
            }
        }

        for ( int __ = 0; __ < fd_count; __++ ){
            if ( pfds[__].revents & POLLIN ) {

                if ( pfds[__].fd == listener ) {
                    addrlen = sizeof remoteaddr;
                    newfd = accept( listener , ( struct sockaddr *)&remoteaddr , &addrlen );
                    if ( newfd == -1 ){
                        perror("accept");
                    }
                    else {
                        add_to_pfds( &pfds , newfd , &fd_count , &fd_size );
                        printf( "Evaluate:: new connection from %s on #%d\n" , 
                            inet_ntop( remoteaddr.ss_family 
                            , get_in_addr( (struct sockaddr*)&remoteaddr), remoteIP , INET6_ADDRSTRLEN )
                            , newfd );
                    }
                }
                else {
                    int nBytes = recv( pfds[__].fd , buf , sizeof buf , 0 );
                    int sender_fd = pfds[__].fd;

                    if ( nBytes <= 0 ) {
                        if ( nBytes == 0 ){ 
                            printf( "Termination on #%d" , sender_fd );
                        }
                        else {
                            perror("recv");
                        }

                        close( pfds[__].fd );
                        del_from_pfds( pfds , __ , &fd_count );
                    }
                    else {
                        for ( int k = 0; k < fd_count; k++ ) {
                            int dest_fd = pfds[k].fd;
                            if ( dest_fd != listener && dest_fd != sender_fd ) {
                                if ( send( dest_fd , buf , nBytes , 0 ) == -1 ) {
                                    perror( "send" );
                                }
                            }
                        }
                    }
                }
            }
        }
        return 0;
    }

    int les__( void ) {

        int sockfd , new_fd;
        struct addrinfo hints, *les_info, *p;
        struct sockaddr_storage mor_addr;
        socklen_t sin_size;
        struct sigaction sa;
        int yes = 1;
        char s[INET6_ADDRSTRLEN];
        int rv;

        memset( &hints , 0 , sizeof hints );

        hints.ai_family = AF_UNSPEC;
        hints.ai_socktype = SOCK_STREAM;
        hints.ai_flags = AI_PASSIVE;


        if ( ( rv = getaddrinfo( NULL , PORT_ACCEPT , &hints , &les_info ) ) != 0 ) {
            fprintf( stderr , " getaddr info : %s\n" , gai_strerror( rv ) );
            return 1;
        }


        for ( p = les_info; p != NULL; p = p -> ai_next ) {
            if ( ( sockfd = socket( p -> ai_family , p -> ai_socktype , p -> ai_protocol ) ) == -1 ) {
                perror( "les •socket [\u2716]" );
                continue;
            }

            if ( setsockopt( sockfd , SOL_SOCKET , SO_REUSEADDR , &yes , sizeof( int ) ) == -1 ) {
                perror( "les •setsockopt [\u2716]" );
                exit( 1 );
            }

            if ( bind( sockfd , p -> ai_addr , p -> ai_addrlen ) == -1 ) {
                close( sockfd );
                perror( "les •active dir [\u2716]" );
                continue;
            }

            break;
        }


        freeaddrinfo( les_info );

        if ( p == NULL ) {
            fprintf( stderr , "les • [\u2716] —» failed initiating activity\n" );
            exit( 1 );
        }


        if ( listen( sockfd , BACKLOG ) == -1 ) {
            perror( "les •listen [\u2716] —» unable to obtain lingustics" );
            exit( 1 );
        }


        sa.sa_handler = sig_chld_handler;
        sigemptyset( &sa.sa_mask );
        sa.sa_flags = SA_RESTART;

        if ( sigaction( SIGCHLD , &sa , NULL ) == -1 ) {
            perror( "les •sigaction [\u2716]" );
            exit( 1 );
        }


        printf(" les •listening —» \n" );

        while ( 1 ) {
            sin_size = sizeof mor_addr;
            new_fd = accept( sockfd , ( struct sockaddr * )&mor_addr , &sin_size );
            if ( new_fd == -1 ) {
                perror( "les •evaluate [\u2716] —» unable to decipher." );
                return 2;
            }

            inet_ntop( mor_addr.ss_family , get_in_addr( ( struct sockaddr * )&mor_addr ) , s , sizeof s );
            printf( "\n—» les•mor —»\n\t%s\n" , s );

            if ( !fork() ) {
                close( sockfd );
                if ( send( new_fd , "Hello World!" , 13 , 0 ) == -1 ) 
                    perror( "les •sending [\u2716] —» unable to transfer .ather" );             
                close( new_fd );
                exit( 0 );  
            }
            close( new_fd );
        }

        return 0;
    }
    
    void sig_chld_handler( int __signal ) {
        int saved_errno = errno;

        while ( waitpid( -1 , NULL , WNOHANG ) > 0 );

        errno = saved_errno;
    }

    void *get_in_addr( struct sockaddr *__s_addr ) {
        if ( __s_addr -> sa_family == AF_INET ) {
            return &( ( ( struct sockaddr_in * ) __s_addr ) -> sin_addr );
        }
        return &( ( ( struct sockaddr_in6 * ) __s_addr ) -> sin6_addr );
    }

    int proto_les( void ) {
        fd_set master;
        fd_set read_fds;
        int fdmax;

        int listener;
        int newfd;
        struct sockaddr_storage remoteaddr;
        socklen_t addrlen;
        char buf[MAX_STR];
        int nBytes;
        char remoteIP[INET6_ADDRSTRLEN];
        int yes=1;
        int i,k,rv;
        struct addrinfo hints, *les_info, *p;

        FD_ZERO( &master );
        FD_ZERO( &read_fds );

        memset( &hints , 0 , sizeof hints );
        hints.ai_family = AF_UNSPEC;
        hints.ai_socktype = SOCK_STREAM;
        hints.ai_flags = AI_PASSIVE;

        if ( ( rv = getaddrinfo( NULL , PORT_ACCEPT , &hints , &les_info ) ) != 0 ) {
            fprintf( stderr , " getaddr info : %s\n" , gai_strerror( rv ) );
            return 1;
        }

        for ( p = les_info; p != NULL; p = p -> ai_next ) {
            listener = socket( p -> ai_family , p -> ai_socktype , p -> ai_protocol );
            if ( listener < 0 ) {
                continue;
            }


            setsockopt( listener , SOL_SOCKET , SO_REUSEADDR , &yes , sizeof( int ) );
            if ( bind( listener , p -> ai_addr , p -> ai_addrlen ) < 0 ) {
                close( listener );
                continue;
            }
            break;
        }

        if ( p == NULL ) {
            fprintf( stderr , "Atherles failed\n" );
            return 2;
        }

        freeaddrinfo( les_info );
        if ( listen( listener , 10 ) == -1 ) {
            perror( "listening failed\n" );
            return 2;
        }

        FD_SET( listener , &master );
        fdmax = listener;

        for ( ;; ) {
            read_fds = master;
            if ( select( fdmax + 1 , &read_fds , NULL , NULL , NULL ) == -1 ) {
                perror("select");
                return 2;
            }

            for ( i = 0; i<=fdmax; i++ ) {
                if ( FD_ISSET( i , &read_fds ) ) {
                    if ( i == listener ) {
                        addrlen = sizeof remoteaddr;
                        newfd = accept( listener , ( struct sockaddr *)&remoteaddr , &addrlen );
                        if ( newfd == -1 ) {
                            perror("accept");
                            continue;
                        }
                        else {
                            FD_SET( newfd , &master );
                            if ( newfd > fdmax ) {
                                fdmax = newfd;
                            }
                            printf("AtherLes :: selected new connection from %s on %d\n\n" 
                                , inet_ntop( remoteaddr.ss_family , get_in_addr((struct sockaddr *)&remoteaddr)
                                    , remoteIP , INET6_ADDRSTRLEN),
                                        newfd);
                        }
                    }
                    else {
                        if ( ( nBytes = recv( i , buf , sizeof buf , 0 ) ) <= 0 ) {
                            if ( nBytes == 0 ) {
                                printf( "Atherles :: %d is out\n" , i );
                            }
                            else {
                                perror("recv");
                            }
                            close(i);
                            FD_CLR( i , &master );
                        }
                        else {
                            for ( k = 0; k <= fdmax; k++ ) {
                                if ( FD_ISSET( k , &master ) ) {
                                    if ( k != listener && k != i ) {
                                        if ( send( k , buf , nBytes , 0 ) == -1 ) {
                                            perror( "send" );
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
            }
        }

        return 0;
    } 

    int __mor( void ) {

        int sockfd , numbytes;
        char buf[MAX_FILE];
        struct addrinfo hints , *les_info , *p;
        int rv;
        char s[INET6_ADDRSTRLEN];


        memset( &hints , 0 , sizeof hints );
        hints.ai_family = AF_UNSPEC;
        hints.ai_socktype = SOCK_STREAM;

        if ( ( rv = getaddrinfo( "127.0.0.1" , PORT_ACCEPT , &hints , &les_info ) ) != 0 ) {
            fprintf( stderr , "mor » no ather [\u2716] —» %s\n" , gai_strerror( rv ) );
            return 1;
        }


        for ( p = les_info; p != NULL; p = p -> ai_next ) {
            if ( ( sockfd = socket( p -> ai_family , p -> ai_socktype , p -> ai_protocol ) ) == -1 ) {
                perror( "mor » mirror [\u2716] —» failed " );
                return 2;
            }

            if ( connect( sockfd , p -> ai_addr , p -> ai_addrlen ) == -1 ) {
                close( sockfd );
                perror( "mor » onconnect [\u2716] —» failed" );
                continue;
            }
            break;
        }

        if ( p == NULL ) {
            fprintf( stderr , "mor » reply [\u2716] —» failed activating les\n" );
            return 2;
        }

        inet_ntop( p -> ai_family , get_in_addr( ( struct sockaddr * ) p -> ai_addr ) , s , sizeof s );

        printf( "\n—» mor•les —»");
        freeaddrinfo( les_info );

        if ( ( numbytes = recv( sockfd , buf , MAX_PROTO - 1 , 0 ) ) == -1 ) {
            perror( "morles » no .ather [\u2716] —» unable to verify .ather" );
            exit( 1 );
        }

        buf[numbytes] = '\0';

        printf( "»\n\t%s\n" , buf );
        close( sockfd );
        return 0;
    }

    int proto_mor( void ) {
        int sockfd , numbytes;
        char buf[1024];
        struct addrinfo hints , *les_info , *p;
        int rv;
        char s[INET6_ADDRSTRLEN];


        memset( &hints , 0 , sizeof hints );
        hints.ai_family = AF_UNSPEC;
        hints.ai_socktype = SOCK_STREAM;

        if ( ( rv = getaddrinfo( "127.0.0.1" , PORT_ACCEPT , &hints , &les_info ) ) != 0 ) {
            fprintf( stderr , "mor » no ather [\u2716] —» %s\n" , gai_strerror( rv ) );
            return 1;
        }


        for ( p = les_info; p != NULL; p = p -> ai_next ) {
            if ( ( sockfd = socket( p -> ai_family , p -> ai_socktype , p -> ai_protocol ) ) == -1 ) {
                perror( "mor » mirror [\u2716] —» failed " );
                return 2;
            }

            if ( connect( sockfd , p -> ai_addr , p -> ai_addrlen ) == -1 ) {
                close( sockfd );
                perror( "mor » onconnect [\u2716] —» failed" );
                continue;
            }
            break;
        }

        if ( p == NULL ) {
            fprintf( stderr , "mor » reply [\u2716] —» failed activating les\n" );
            return 2;
        }

        // inet_ntop( p -> ai_family , get_in_addr( ( struct sockaddr * ) p -> ai_addr ) , s , sizeof s );


        printf( "\n—» mor•les —»");
        freeaddrinfo( les_info );
        int tempp =  write( sockfd , "Hello you" , 10 );

        printf("Write :: %d\n\n",  tempp );

        if ( ( numbytes = recv( sockfd , buf , 1024 - 1 , 0 ) ) == -1 ) {
            perror( "morles » no .ather [\u2716] —» unable to verify .ather" );
            exit( 1 );
        }

        buf[numbytes] = '\0';

        printf( "\n\t»%s\n" , buf );
        close( sockfd );
        return 0;
    }

    // __ buffer
    // b base 
    // `_` is a value of the unsigned char appended 
    unsigned int _pwrite( unsigned int *__fd , char *__fmt , struct __protocol *p ) {
        unsigned int __size = 0; 
        unsigned int __len = 0;
        unsigned char *__ = calloc( MAX_STR , sizeof( unsigned char ) ); 
        for( ; *__fmt != '\0'; __fmt++ ){
            switch( *__fmt ) {
                // p -> _len
                case 'a':  
                    __size += 2;
                    i16( __ , p -> _len );
                    __ += 2;
                    break;
                // p -> _name
                case 'A':
                    __len = strlen( p -> _name );
                    if ( __len != p -> _len ) {
                        perror( "Protocol issue : 1 -> name length does not match str length" );
                        return 0;
                    }
                    __size += __len + 2;
                    i16( __ , __len );
                    __ += 2;
                    memcpy( __ , p -> _name , __len );
                    __ += __len;
                    break;
                // p -> _size 
                case 'e':
                    __size += 2;
                    i16( __ , p -> _size );
                    __ += 2;
                    break;
                // p -> _diff
                case 'd':
                    __size += 1;
                    *__++ = p -> _diff;
                    break;
                // p -> _type
                case 'N':
                    __len = strlen( p -> _type );
                    __size += __len + 2;
                    i16( __ , __len );
                    __ += 2;
                    memcpy( __ , p -> _type , __len );
                    __ += __len;
                    break;
                // p -> _selector
                case 'M':
                    __size += 8;
                    i64( __ , p -> _selector );
                    __ += 8;
                    break;
                // p -> _bin
                case 'E':
                    __len = strlen( p -> _bin );
                    __size += __len + 2;
                    i16( __ , __len );
                    __ += 2;
                    memcpy( __ , p -> _bin , __len );
                    __ += __len;
                    break;
            }
            __len = 0;
        }
        return __size;
    }    

    #ifndef va_list
        #include <stdarg.h>
    #endif
    int __pathify( char *node__name , char *node__serv , typeproto *__ , int __override , ... ) {
        int __status = 2;
        va_list __vars;
        if ( node__name != NULL || node__serv != NULL ) {
            __ -> node__ = node__name;
            __ -> serv__ = node__serv;
            if ( !__override ) {
                // only accept socket streams
                // no more dgram bs
                __ -> hints__ -> ai_socktype = SOCK_STREAM;
                // adaptive to ip addr len
                __ -> hints__ -> ai_family = A_ANY;
                // check to see if `les` then socket :: <bind,accept>
                if ( __ -> name__ == A_MOR || node__name[0] == '@' || 
                    strcmp( node__serv , ATHER_SERVICE ) == 0 ) {
                    __ -> hints__ -> ai_flags = AI_PASSIVE;
                }
                if ( __ -> name__ == A_LES ) {
                    __ -> hints__ -> ai_flags = 0;
                }
            }
            else {
                va_start( __vars , __override );
                while ( __override > 0 ) {
                    __ -> hints__ = va_arg( __vars , struct addrinfo * );           
                    __override--;
                }
                va_end( __vars );
            }
            if (( __status = getaddrinfo( node__name , node__serv , __ -> hints__ , &(__ -> res__) )) == 0 ){
                __status = 0;
                struct addrinfo *_;
                for ( _ = __ -> res__; _ != NULL; _ = _ -> ai_next ) {
                    void *addr;
                    if ( ( addr = __ip( __ -> at__ , _ -> ai_addr ) ) != X_NODEF ) {
                        __status = 0;
                    }
                }
                free( __ -> res__ );
            }
            else {
                printf( "__pathify :: %s\n" , gai_strerror( __status ) );
            }
        }
        return __status;
    }
    #endif
#endif




// v1
// #include <stdio.h>
// #include <sys/socket.h>
// #include <arpa/inet.h>
// #include <string.h>
// #include <unistd.h>
// #include <pthread.h> //for threading , link with lpthread
// #include <stdlib.h>
// #include <stddef.h>
// #include <errno.h>
// #include <sys/un.h>



// // by GNU.
// int make_named_socket( const char *filename );
// int _make_simple_socket( int socket_desc );
// int _listen( int socket_desc );
// int _make_raw_socket( int _socket_desc );
// void *connection_handler(void *);
// int _make_super_socket( int _external_socket , int _local_socket );



// int main( int argc , char const *argv[] ) {
// 	int __socket,socket__ = 0;
// 	int s__socket = _make_super_socket( _make_simple_socket( socket__ ) , _make_raw_socket( __socket ) );
// 	return 0;
// 	// return _make_and_listen();
// }


// int _make_raw_socket( int _socket_desc ) {
//   	struct sockaddr_un _les;
// 	//Prepare the sockaddr_in structure
// 	_les.sun_family = AF_LOCAL;
// 	strncpy( _les.sun_path , "x" , sizeof( _les.sun_path ) );
//  	int size = (offsetof (struct sockaddr_un, sun_path)
//           + strlen (_les.sun_path));

// 	( _socket_desc = socket(AF_LOCAL , SOCK_DGRAM , 0) ) == -1 ? 2 : _socket_desc;
// 	//Bind
// 	if( bind( _socket_desc , (struct sockaddr *)&_les , sizeof( _les ) ) < 0 ) {
// 		puts("bind failed : raw");
// 	}
// 	printf("%d\n\n\n", _socket_desc);
// 	return 	_socket_desc;
// }


// int _make_simple_socket( int _socket_desc ) {
// 	struct sockaddr_in _listener;
// 	//Prepare the sockaddr_in structure
// 	_listener.sin_family = AF_INET;
// 	_listener.sin_addr.s_addr = INADDR_ANY;
// 	_listener.sin_port = htons( 9999 );

// 	( _socket_desc = socket ( AF_INET , SOCK_STREAM , 0 ) ) == -1 ? 2 : _socket_desc;
// 	//Bind
// 	if( bind( _socket_desc ,(struct sockaddr *)&_listener , sizeof( _listener )) < 0) {
// 		puts("bind failed : simple");
// 	}
// 	printf("%d\n\n\n", _socket_desc);
// 	return 	_socket_desc;
// }


// int _make_super_socket( int _external_socket , int _local_socket ) {
// 	int new_socket , c , *new_sock;
// 	char e_send[2000];
// 	char *_eval = "\0";
// 	char __send[100] = "recieved\n\n .aether";
// 	struct sockaddr_in client;

// 	listen( _external_socket , 3 );
// 	listen( _local_socket , 4 );
	
// 	//Accept and incoming connection
// 	printf("\n\033[38;2;84;84;84mAether\e[0;37m :: %s" , "(L)es :\n");
// 	c = sizeof( struct sockaddr_in );

// 	while ( 1 ) {
// 		if ( ( new_socket = recv( _local_socket , e_send , 1999 , 0 ) ) > 0 ) {
// 		printf( ".aether :: %ld,-> \n%s\n" , strlen( e_send ) , e_send );

// 		}
// 		if ( ( new_socket = connect( _external_socket , (struct sockaddr *)&client, sizeof( c ) ) ) > 0 ) {
// 			printf( "new con -> " );
// 			write( new_socket , "new" , 4 );
// 		}
// 	}

// 	// while ( ( new_socket = recv( _local_socket , e_send , 1999 , 0 ) ) > 0 ) {
// 	// 	printf( ".aether :: %ld,-> \n%s\n" , strlen( e_send ) , e_send );
// 	// }


// 	printf("\n recv donz \n");

// 	if ( new_socket < 0 ) {
// 		perror( "accept failed" );
// 		return 1;
// 	}
// 	// printf("Closing");
// 	// close( socket_desc );

// 	close( _external_socket );
// 	close( _local_socket );

// 	return 0;


// }




// int _listen( int socket_desc ) {
// 	int new_socket , c , *new_sock;
// 	char e_send[2000];
// 	char *_eval;

// 	listen(socket_desc , 3);
	
// 	//Accept and incoming connection
// 	printf("\n\033[38;2;84;84;84mAether\e[0;37m :: %s" , "(L)es :\n");
// 	c = sizeof( struct sockaddr_in );

// 	while ( ( new_socket = recv( socket_desc , e_send , 1999 , 0 ) ) > 0 ) {
// 		printf( ".aether :: %ld,-> \n%s\n" , strlen( e_send ) , e_send );
// 	}


// 	printf("\n recv donz \n");

// 	if ( new_socket < 0 ) {
// 		perror( "accept failed" );
// 		return 1;
// 	}
// 	// printf("Closing");
// 	// close( socket_desc );

// 	close( socket_desc );

// 	return 0;
// }

// void *connection_handler(void *socket_desc) {
// 	//Get the socket descriptor
// 	int sock = *(int*)socket_desc;
// 	int read_size;
// 	char *message , client_message[2000];
	
// 	//Send some messages to the client
// 	message = "Greetings! I am your connection handler\n";
// 	write(sock , message , strlen(message));
	
// 	message = "Now type something and i shall repeat what you type \n";
// 	write(sock , message , strlen(message));
	
// 	//Receive a message from client
// 	while( (read_size = recv(sock , client_message , 2000 , 0)) > 0 ) {
// 		//Send the message back to client
// 		write(sock , client_message , strlen(client_message));
// 	}
	
// 	if(read_size == 0) {
// 		puts("Client disconnected");
// 		fflush(stdout);
// 	}
// 	else if(read_size == -1) {
// 		perror("recv failed");
// 	}

// 	printf("%s" , "Handler Freed @");	
// 	//Free the socket pointer
// 	free(socket_desc);
	
// 	return 0;
// }



// int make_named_socket (const char *filename) {
//   struct sockaddr_un name;
//   int sock;
//   size_t size;

//   /* Create the socket. */
//   sock = socket (PF_LOCAL, SOCK_DGRAM, 0);
//   if (sock < 0) {
//       perror ("socket");
//       exit (EXIT_FAILURE);
//     }

//   /* Bind a name to the socket. */
//   name.sun_family = AF_LOCAL;
//   strncpy (name.sun_path, filename, sizeof (name.sun_path));
//   printf("\nSocket :: @ : %s\n", name.sun_path );
//   name.sun_path[sizeof (name.sun_path) - 1] = '\0';

//   /* The size of the address is
//      the offset of the start of the filename,
//      plus its length (not including the terminating null byte).
//      Alternatively you can just do:
//      size = SUN_LEN (&name);
//  */
//   size = (offsetof (struct sockaddr_un, sun_path)
//           + strlen (name.sun_path));

//   if (bind (sock, (struct sockaddr *) &name, size) < 0) {
//       perror ("bind");
//       exit (EXIT_FAILURE);
//     }


//   return _listen( sock );
// }

















// v2
// int main( int argc, char const *argv[] ) {
// 	if ( argc > 1 ) {
// 		return _client_local( argc , argv );
// 	}
// 	return _client( argv[1] );
// }


// int _client_local( int argc, char const *argv[] ) {

// 	int socket_desc;
// 	struct sockaddr_in _listener;
// 	char *_les, mor_[2000];

// 	socket_desc = socket( AF_INET , SOCK_STREAM , 0 );
// 	if ( socket_desc == -1 ) {
// 		printf( AETHER_ERROR , "CONNC" , "Socket Cannot be created" );
// 		return 2;
// 	}

// 	_listener.sin_family = AF_INET;
// 	_listener.sin_addr.s_addr = inet_addr( "127.0.0.1" );
// 	_listener.sin_port = htons( 9999 );

// 	if ( connect( socket_desc , (struct sockaddr *)&_listener , sizeof( _listener ) ) < 0 ) {
// 		puts( "connect error" );
// 		return 0;
// 	}

// 	puts( "connected" );


// 	//Send some data
// 	_les = "GET / HTTP/1.1\r\n\r\n";
// 	if( send( socket_desc , _les , strlen( _les ) , 0 ) < 0 ) {
// 		puts( "Send failed" );
// 		return 1;
// 	}
// 	puts( "data sent\n" );


// 	//Receive a reply from the server
// 	if( recv( socket_desc, mor_ , 2000 , 0 ) < 0 ) {
// 		puts( "recv failed" );
// 	}
// 	puts( "Reply received\n" );
// 	puts( mor_ );

// 	close( socket_desc );
	
// 	return 0;
// }

// int _client( char const *argv ) {
// 	int socket_desc;
// 	// struct sockaddr_in _les;
//   	struct sockaddr_un _les;
// 	char evaluate_[AETHER_FILE_BUFFER], mor_[2000];


// 	socket_desc = socket( AF_LOCAL , SOCK_DGRAM , 0 );
// 	if ( socket_desc < 0 ) {
// 		perror( "Cannot create socket" );
// 		return 2;

// 	}

// 	_les.sun_family = AF_LOCAL;
// 	strncpy( _les.sun_path , "x" , sizeof( _les.sun_path ) );


//   	if (connect ( socket_desc, (struct sockaddr *) &_les, sizeof( _les )) < 0) {
//       perror ("connect");
//       exit (EXIT_FAILURE);
//     }

// 	//Send some data
// 	sprintf( evaluate_ , "PATH:=Aether\nCONNC:=\nCALL:=entry\nENTRY{ ##python3 }\n\r" );
// 	if( send( socket_desc , evaluate_ , strlen( evaluate_ ) , 0 ) < 0 ) {
// 		puts( "Send failed" );
// 		return 1;
// 	}
// 	puts( "data sent\n" );


// 	close( socket_desc );
// 	return 0;
// }









// v0
// int _client() {
// 	int socket_desc;
// 	struct sockaddr_in _listener;
// 	char *_les, mor_[2000];

// 	socket_desc = socket( AF_INET , SOCK_STREAM , 0 );
// 	if ( socket_desc == -1 ) {
// 		printf( AETHER_ERROR , "CONNC" , "Socket Cannot be created" );
// 		return 2;
// 	}

// 	_listener.sin_addr.s_addr = inet_addr( "127.0.0.1" );
// 	_listener.sin_family = AF_INET;
// 	_listener.sin_port = htons( 8888 );

// 	if ( connect( socket_desc , (struct sockaddr *)&_listener , sizeof( _listener ) ) < 0 ) {
// 		puts( "connect error" );
// 		return 0;
// 	}

// 	puts( "connected" );


// 	//Send some data
// 	_les = "GET / HTTP/1.1\r\n\r\n";
// 	if( send( socket_desc , _les , strlen( _les ) , 0 ) < 0 ) {
// 		puts( "Send failed" );
// 		return 1;
// 	}
// 	puts( "data send\n" );


// 	//Receive a reply from the server
// 	if( recv( socket_desc, mor_ , 2000 , 0 ) < 0 ) {
// 		puts( "recv failed" );
// 	}
// 	puts( "Reply received\n" );
// 	puts( mor_ );

// 	close( socket_desc );
// }

// int main( int argc, char const *argv[] ) {

// 	int socket_desc;
// 	struct sockaddr_in _listener;
// 	char *_les, mor_[2000];

// 	socket_desc = socket( AF_INET , SOCK_STREAM , 0 );
// 	if ( socket_desc == -1 ) {
// 		printf( AETHER_ERROR , "CONNC" , "Socket Cannot be created" );
// 		return 2;
// 	}

// 	_listener.sin_addr.s_addr = inet_addr( "127.0.0.1" );
// 	_listener.sin_family = AF_INET;
// 	_listener.sin_port = htons( 8888 );

// 	if ( connect( socket_desc , (struct sockaddr *)&_listener , sizeof( _listener ) ) < 0 ) {
// 		puts( "connect error" );
// 		return 0;
// 	}

// 	puts( "connected" );


// 	//Send some data
// 	_les = "GET / HTTP/1.1\r\n\r\n";
// 	if( send( socket_desc , _les , strlen( _les ) , 0 ) < 0 ) {
// 		puts( "Send failed" );
// 		return 1;
// 	}
// 	puts( "data send\n" );


// 	//Receive a reply from the server
// 	if( recv( socket_desc, mor_ , 2000 , 0 ) < 0 ) {
// 		puts( "recv failed" );
// 	}
// 	puts( "Reply received\n" );
// 	puts( mor_ );

// 	close( socket_desc );
	
// 	return 0;
// }

