/// atherpoints \\\

#include "point.h"
#include "nai.h"

/**
errors 
 * 
 * -1 :: cannot get current working dir
 * -2 :: os path too long
 * -3 :: lbb cannot be `access`ed()
 * -4 :: no atherpoint found
 * -5 :: cannot get host details `gethostbyname` failed
 * -6 :: cannot initiate communication socket
 * -7 :: could not bind to network address
 * -8 :: could not listen on socket
**/

#ifndef __point_conf
	#ifndef ap_entry
	    #define _ap_entry __ap_entry
	    #define ap_entry __ap_entry( ap_name , F_OK )
	    int __ap_entry( char *_e_path , int _e_type ) {
	        int __ap = 0 , __flags = ( F_OK | ( _e_type == 0 ? R_OK : _e_type ) );
	        if ( access( _e_path , __flags ) == 0 ) {
	            __ap = open( _e_path , __flags );
	        }
	        return __ap > 0 ? __ap : 0;
	    }
	    #ifndef _ap_r_entry
	        #define _ap_r_entry() __ap_entry( ap_name , R_OK )
	    #endif
	    #ifndef _ap_w_entry
	        #define _ap_w_entry() __ap_entry( ap_name , W_OK )
	    #endif
	    #ifndef _ap_l_entry    
	        #define _ap_l_entry() __ap_entry( ap_name , ( R_OK | W_OK ) )
	    #endif
	#else
	    #ifndef ap_r_entry
	        #define ap_r_entry _ap_r_entry
	        int _ap_r_entry() {
	            int __apr , __flags = ( R_OK );
	            if ( access( ap_name , __flags ) == 0 ) {
	                __flags = O_RDONLY;
	                __apr = open( ap_name , __flags );
	            }
	            return __apr > 0 ? __apr : 0;
	        }
	    #endif
	    #ifndef ap_w_entry
	        #define ap_w_entry _ap_w_entry
	        int _ap_w_entry() {
	            int __apr , __flags = ( W_OK );
	            if ( access( ap_name , __flags ) == 0 ) {
	                __flags = O_WRONLY;
	                __apr = open( ap_name , __flags );
	            }
	            return __apr > 0 ? __apr : 0;   
	        }
	    #endif
	#endif

	#ifndef ap_check
	    #define ap_check __ap_fifo
	    int __ap_fifo( char *point_name , struct stat *pstat ) {
	        /**
	         * mutex
	         * because after `stat()`
	         * st_nlink is atleast >= 1
	        **/
	        if ( ( pstat -> st_nlink == 0 ) \
	            && stat( point_name , pstat ) == 0 ) { return 1; }
	        return 0;
	    }
	#endif

	#ifndef ap_make
	    #define ap_make __ap_make
	    int __ap_make() {
	        if ( !mkfifo( ap_name , ( S_IRWXU | S_IXGRP | S_IXOTH ) ) ) {
	            return 1;
	        }
	        return 0;
	    }
	#endif
#endif

#ifndef __point_io
	#ifndef process_entry
	int process_entry( char *p_entry , int pe_type ) {

	    return _ap_entry( p_entry , pe_type );    
	}
	#endif

	#ifndef app_engine
	int app_engine( struct p_io *engint ) {
	    int c = 0, r_bytes;
	    char _ , __[4096];
	    memset( &__ , 0 , sizeof( __ ) );

	    #ifdef DEBUG
	        printf( "engint : FIFO FD = %d\n" , engint -> io_pfd );
	        printf( "engint :: reading from fifo\n" );
	    #endif

	    while ( ( r_bytes = read( engint -> io_pfd , &__ , 4096 ) ) > 0 ) {
	        c += r_bytes;
	        _ = __[c-1];
	        if ( _ == 10 ) {
	            #ifdef DEBUG
	                printf( "engint :: processing entry\n" );
	            #endif
	            if ( !process_entry( __ , c ) ) {
	                printf("entry processed\n");
	                break;
	            }
	            memset( &__ , 0 , c * sizeof( char ) );
	            c = 0 , r_bytes = 0;
	            continue;
	        }
	        r_bytes = 0;
	    }
	    return 0x0;
	}
	#endif

	#ifndef socket_execute
	int socket_execute( struct p_io *sexec ) {

	    int count = 0, r_bytes = 0;
	    char _ , __[4096];
	    memset( &__ , 0 , sizeof( __ ) );

	    #ifdef DEBUG
	        printf( "sexec : FIFO fd : %d \n" , sexec -> io_pfd );
	        printf( "sexec :: reading from stdin\n" );
	    #endif

	    while ( ( r_bytes = read( 0 , &__ , 4096 ) ) > 0 ) {
	        count += r_bytes;
	        _ = __[count-1];

	        printf( "\n\n\n _ = (%c) \n\n\n" , _ );
	        #ifdef DEBUG
	            printf( "sexec : bytes read = %d : total bytes = %d\n" , r_bytes , count );
	        #endif
	        if ( _ == 10 ) {
	            #ifdef DEBUG
	                printf( "sexec :: writing to FIFO : len = %d, buf = %s\n" , count , __ );
	            #endif
	            if ( write( sexec -> io_pfd , __ , 4096 ) > 0 ) {
	                memset( &__ , 0 , count );
	                count = 0 , r_bytes = 0;
	                continue;
	            }
	            break;
	        }
	        else if ( _ == 27 ) {
	            printf( "sexec :: exit\n" );
	            return 0;
	        }
	        r_bytes = 0;
	    }
	    printf( "sexec :: execution ended\n" );
	    return 0;
	}
	#endif

	#ifndef p_reader
	    #define p_reader __init_reader
	    int __init_reader(){
	        point_io __reader , __writer;
	        memset( &__reader , 0 , __size_p_io );
	        memset( &__writer , 0 , __size_p_io );
	        ap.st.p_known = __reader;
	        ap.st.p_annon = __writer;
	        // get the current pid
	        __reader.io_pid = getpid();
	        // fork the process for the new pid
	        if ( ( __writer.io_pid = fork() ) == -1 ) {
	            printf( "cannot start the atherpoint :: fork\n" );
	            return -2;
	        }
	        // check calling process
	        if ( is_reader ) {
	            printf( "current pid for reading :: %ld\n" , __reader.io_pid );
	            // read
	            if ( ( __reader.io_pfd = _ap_r_entry() ) == 0 ) {
	                printf( "cannot open atherpoint for reading\n");
	                return -3;
	            }
	            printf( "\n-#-#-# engine -#-#-#\n" );
	            return app_engine( &__reader );
	        }
	        else {
	            printf( "current pid for writing :: %ld\n" , __writer.io_pid );
	            // write 
	            if ( ( __writer.io_pfd = _ap_w_entry() ) == 0 ) {
	                printf( "cannot open atherpoint for writing\n");
	                return -3;
	            }
	            printf( "\n#-#-# socket executive #-#-#\n" );
	            return socket_execute( &__writer );
	        }
	        return 0;
	    }
	#endif
#endif

#ifdef __signals
	#include <errno.h>
	#include <sys/wait.h>
	void sigchld_handler( int s ) {
		// save errorno & restore
	    // as `waitpid` might overwrite
	    int saved_errno = errno;

	    while( waitpid( -1 , NULL , WNOHANG ) > 0 );

	    errno = saved_errno;
	}
#endif

#ifndef __network_interfaces
	#define __network_interfaces 1
		/***
		 * interface calls only check and return the
		 * native structure for the interface
		 * i.e :: only ATOMIC && GET but no SET is allowed here.
		 */
		// node number : point
		// mount path : lbb
		int __mac_ai( struct a_inmp *_inmp ) {
			struct stat __st;
			char *path = _inmp -> imp;
			// zero the initial path
			char __path[max_path];
			memset( __path , 0 , max_path );
			// get the current working dir
			if ( getcwd( __path , max_path ) == NULL ) {
				#ifdef DEBUG
				printf( "cannot get working dir\n" );
				#endif
				return -1;
			}
			// re-zero the `mp`
			memset( path , 0 , max_path );
			// copy the path to struct element
			memcpy( path , __path , strlen( __path ) );
			// add the `.lbb` name to the path
			if ( __path_unix( path , ".lbb" ) == NULL ) {
				printf( "cannot construct lbb path\n" );
				return -2;
			}
			// check calling process permissions
			// for constructed path to lbb
			if ( access( path , F_OK|R_OK ) != 0 ) {
				#ifdef DEBUG
				printf( "lbb cannot be accessed\n" );
				#endif
				return -3;
			}
			// attach `atherpoint` to the directory path
			if ( __path_unix( __path , "atherpoint" ) == NULL ) {
				printf( "cannot construct point path\n" );
				return -2;
			}
			// call the FIFO `stat` to retreive `inn`
			if ( stat( __path , &__st ) == -1 ) {
				printf("cannot initiate unix interface\n");
				return -4;				
			}
			// get the inodenum from the struct `stat`
			// and add the value to `_inmp`
			return 0;
		}
		// S B L A
		int __loc_ai( struct a_isok *_isok ) {
			
			// check ipv4 socket first
			int _sok = socket( AF_INET , SOCK_STREAM , 0 ) , _ip6flag = 0;
			#ifdef DEBUG
				printf( "creating socket IPV4 :: " );
			#endif
			if ( _sok < 0 ) {
				_ip6flag = 1;
				#ifdef DEBUG
					printf( "failed.\ncreating socket IPV6 :: " );
				#endif
				if ( ( _sok = socket( AF_INET6 , SOCK_STREAM , 0 ) ) < 0 ) {
					#ifdef DEBUG
						printf( "failed.\n exiting.\n" );
					#endif
					printf( "cannot initiate communication socket\n" );
					return -6;
				}
			}
			#ifdef DEBUG
				printf( "success\n" );
			#endif

			printf( "socket result :: %d\n" , _sok );


			struct sockaddr_in _iaddr4;
			struct sockaddr_in6 _iaddr6;


			void *_iaddr;
			int res, _iasize = sizeof( struct sockaddr_in ) , _ia6size = sizeof( struct sockaddr_in6 );


			if ( _ip6flag ) {
				_iaddr6.sin6_family = AF_INET6;
				_iaddr6.sin6_port = sp_network;
				res = inet_pton( AF_INET6 , s_local2v6 , &_iaddr6.sin6_addr );
				res = bind( _sok , (struct sockaddr*)&_iaddr6 , _ia6size );
			}else{
				_iaddr4.sin_family = AF_INET;
				_iaddr4.sin_port = sp_network;
				res = inet_pton( AF_INET , s_local , &_iaddr4.sin_addr );
				res = bind( _sok , (struct sockaddr*)&_iaddr4 , _iasize );
			}

			if ( res != 0 ) {
				printf( "could not bind to local network address.\n" );
				return -7;
			}
			

			printf( "binding result :: %d\n" , res );

			struct sockaddr_storage their_addr; // connector's address information
			int _newfd;
			socklen_t sin_size;
			char s[INET6_ADDRSTRLEN];

			if ( listen( _sok , 10 ) == -1 ) {
				printf("cannot listen on socket.\n");
				return -8;
			}

			printf("server: waiting for connections...\n");

			while(1) { 
				sin_size = sizeof( their_addr );
				_newfd = accept(_sok, (struct sockaddr *)&their_addr, &sin_size);
				if ( _newfd == -1 ) {
					// cannot accept
					continue;
				}

				inet_ntop(their_addr.ss_family,
				get_in_addr((struct sockaddr *)&their_addr),
				s, sizeof s);
				printf("server: got connection from %s\n", s);

				if (!fork()) { // this is the child process
					close( _sok ); // child doesn't need the listener
					if ( send( _newfd , "ather :: nai : 1\n" , 17 , 0 ) == -1 ) {
						printf( "could not send back data\n" );
					}
					close( _newfd );
					exit( 0 );
				}

				close( _newfd );  // parent doesn't need this
			}
		}
		// global socket && sbla
		int __glo_ai( struct a_idns *_idns ) {
			int sockfd, new_fd;  // listen on sock_fd, new connection on new_fd
			struct addrinfo hints, *servinfo, *p;
			struct sockaddr_storage their_addr; // connector's address information
			socklen_t sin_size;
			// struct sigaction sa;
			int yes=1;
			char s[INET6_ADDRSTRLEN];
			int rv;

			memset(&hints, 0, sizeof hints);
			hints.ai_family = AF_UNSPEC;
			hints.ai_socktype = SOCK_STREAM;
			hints.ai_flags = AI_PASSIVE; // use my IP

			if ( ( rv = getaddrinfo( NULL , __n_glo_socket , &hints , &servinfo ) ) != 0 ) {
				fprintf( stderr , "getaddrinfo: %s\n" , gai_strerror( rv ) );
				return 1;
			}

			// loop through all the results and bind to the first we can
			for(p = servinfo; p != NULL; p = p->ai_next) {
				if ((sockfd = socket(p->ai_family, p->ai_socktype,
						p->ai_protocol)) == -1) {
					perror("server: socket");
					continue;
				}

				if (setsockopt(sockfd, SOL_SOCKET, SO_REUSEADDR, &yes,
						sizeof(int)) == -1) {
					perror("setsockopt");
					exit(1);
				}
				
				if (bind(sockfd, p->ai_addr, p->ai_addrlen) == -1) {
					close(sockfd);
					perror("server: bind");
					continue;
				}
				inet_ntop(p->ai_family,
					get_in_addr((struct sockaddr *)&p->ai_addr),
					s, sizeof s);
				printf("server: running on socket :: %s\n", s);

				break;
			}

			freeaddrinfo(servinfo); // all done with this structure

			if ( p == NULL ) {
				fprintf( stderr , "server: failed to bind\n" );
				exit( 1 );
			}

			if ( listen( sockfd, __q_len ) == -1 ) {
				perror( "listen" );
				exit( 1 );
			}

			// sa.sa_handler = sigchld_handler; // reap all dead processes
			// sigemptyset(&sa.sa_mask);
			// sa.sa_flags = SA_RESTART;
			// if (sigaction(SIGCHLD, &sa, NULL) == -1) {
			// 	perror("sigaction");
			// 	exit(1);
			// }

			printf("server: waiting for connections...\n");

			while(1) {  // main accept() loop
				sin_size = sizeof their_addr;
				new_fd = accept(sockfd, (struct sockaddr *)&their_addr, &sin_size);
				if (new_fd == -1) {
					perror("accept");
					continue;
				}

				inet_ntop(their_addr.ss_family,
					get_in_addr((struct sockaddr *)&their_addr),
					s, sizeof s);
				printf("server: got connection from %s\n", s);

				if (!fork()) { // this is the child process
					close(sockfd); // child doesn't need the listener
					if (send(new_fd, "Hello, world!", 13, 0) == -1)
						perror("send");
					close(new_fd);
					exit(0);
				}
				close(new_fd);  // parent doesn't need this
			}

			return 0;
		}
		// blockchain socket + network name + netaddr
		int __uni_ai( struct a_ibna *_ibna ) {
			char *__argvs[3] = { "/home/kj/go/bin/geth" , "attach" , NULL };

			execve( "/home/kj/go/bin/geth" , __argvs , NULL );

			return 0x0;
		}
	#ifdef net_interface
		int mac_interface() {
			return __mac_ai( net_interface.__mach );
		}
		int loc_interface() {
			return __loc_ai( net_interface.__loch );
		}
		int glo_interface() {
			return __glo_ai( net_interface.__gloh );
		}
		int uni_interface() {
			return __uni_ai( net_interface.__unih );
		}
	#else
		int mac_interface( struct a_inmp inmp ) {
			return __mac_ai( &inmp );
		}
		int loc_interface( struct a_isok isok ) {
			return __loc_ai( &isok );
		}
		int glo_interface( struct a_idns idns ) {
			return __glo_ai( &idns );
		}
		int uni_interface( struct a_ibna ibna ) {
			return __uni_ai( &ibna );
		}
	#endif


	// delegate
	nai native_interface( int level ) {

		nai __;
		memset( &__ , 0 , sizeof( __ ) );

		int _res = -1;

		switch ( level ) {
			case 0: _res = mac_interface( __.__mach ); break;
			case 1: _res = loc_interface( __.__loch ); break;
			case 2: _res = glo_interface( __.__gloh ); break;
			case 3: _res = uni_interface( __.__unih ); break;
			default: break; 
		}
		return __;
	}
#endif

#ifndef __morles__
	void *evaluate( void *__socket ) {
		//Get the socket descriptor
		int _socket = *(int*)__socket;
		int _aether_size;
		char *message , __mor[AETHER_FILE_BUFFER];

		// message = "(P)ath , (C)onnc , C(all) , ENTRY{}\n";
		// send( _socket , message , strlen(message) , 0 );

		while ( _aether_size = recv( _socket , __mor , sizeof( __mor ) , 0 ) > 0 ) {
			int __mor_size = strlen( __mor );
			// if ( _get_attribs( &request_file ) == 0 ) {
			// 	printf( "\n%s\n" , request_file.A_PATH );
			// }

			if ( __mor_size > 1 ) {
				printf( AETHER_LISTEN , __mor_size , __mor  );
				send( _socket , "request recieved\n\r\n\r" , 22 , 0 );
			}
			else {
				printf( AETHER_ERROR , "les :: evaluate" , ".aether too short" );
				send( _socket , "request denied\n\r\n\r" , 20 , 0 );
			}
		}

		if ( _aether_size == -1 ) {
			printf( AETHER_ERROR , "les :: evaluate" , ".aether recv failed" );
		}
		else if ( _aether_size == 0 ) {
			printf( AETHER_LINE , "les -> mor disconnected" );
			fflush( stdout );
		}

		free( __socket );
		return 0;
	}

	int ather_les( void ) {
		fd_set __main;
		fd_set __reader;
		uint32_t __listener;
		uint32_t group_max , new_fd , n_bytes , yes = 1 , i , k , rv;
		char __buffer[MAX_STR] , remote__ip[INET6_ADDRSTRLEN];
		struct sockaddr_storage __remote;
		struct addrinfo hints , *les_info , *p;

		FD_ZERO( &__main );
		FD_ZERO( &__reader );

		memset( &hints , 0 , sizeof( hints ) );
		hints.ai_family = AF_UNSPEC;
		hints.ai_socktype = SOCK_STREAM;
		hints.ai_flags = AI_PASSIVE;


		if ( ( rv = getaddrinfo( NULL , PORT_ACCEPT , NULL , &les_info ) ) != 0 ) {
	        fprintf( stderr , " getaddr info : %s\n" , gai_strerror( rv ) );
	        return -1;
		}


	    for ( p = les_info; p != NULL; p = p -> ai_next ) {
	    	printf( "Remote IP :: %x\n" , __ip( remote__ip , p -> ai_addr ) );
	    }
	}

	int mor( int argc , char *argv[] ) {
		char message[AETHER_REPLY_MAX]; // = "\n\r\n\rPATH:=Aether\nCONNC:=\nCALL:=entry\nENTRY{ ##python3 }\n\r\n\r";
		a_file aether_file = {0};
		aether_file._name = _AETHER_;
		_file_contents( &aether_file );

		strcpy( message , aether_file._contents );
		mirror( message );
		return 0;
	}

	int mirror( char *_aether ) {
		int _socket;
		struct sockaddr_in server;
		int __temp;
		char __reply[AETHER_REPLY_MAX];
		// char *message = "\nPATH:=\nCONNC:=\nCALL:=\nENTRY{ }\n\r\0";

		_socket = socket( AF_INET , SOCK_STREAM , 0 );
		if ( _socket < 0 ) {
			printf( AETHER_ERROR , "mor :: mirror" , "Socket init failed" );
			return 2;
		}

		server.sin_family = AF_INET;
		server.sin_addr.s_addr = inet_addr("127.0.0.1"); //16777343;
		server.sin_port = htons( 9999 );

		if ( connect( _socket , ( struct sockaddr *) &server , sizeof( server ) ) < 0 ) {
			printf( AETHER_ERROR , "mor :: mirror" , "Socket connection failed" );
			return 2;
		}

		printf( AETHER_SIG );

		if ( send( _socket , _aether , strlen( _aether ) , 0 ) > 0 ) {
			if ( __temp = recv( _socket , __reply , AETHER_REPLY_MAX , 0 ) > 0 ) {
				printf( AETHER_EXEC , __reply );
			}
		}
		printf( AETHER_SIG );
		close( _socket );
		return 0;
	}
#endif

int main( int argc , char const *argv[] ) {
	int _socket , _temp , _c , *_new;
	struct sockaddr_in client,server;
	char *message , __mor[1000];
	int num_threads = 1;


	_socket = socket( AF_INET , SOCK_STREAM , 0 );
	if ( _socket == -1 ) {
		printf( AETHER_ERROR , "les :: init" , "Socket cannot be created" );
		return 2;
	}

	server.sin_family = AF_INET;
	server.sin_addr.s_addr = INADDR_ANY;
	server.sin_port = htons( 9999 );


	if ( bind( _socket , ( struct sockaddr *) &server , sizeof( server ) ) < 0 ) {
		printf( AETHER_ERROR , "les :: init" , "Socket binding failed" );
		return 2;
	}

	listen( _socket , 3 );
	_c = sizeof( struct sockaddr_in );

	printf( AETHER_LES );

	int read_size;
	while ( ( _temp = accept( _socket , ( struct sockaddr *) &client , (socklen_t*) &_c ) ) ) {
		pthread_t sniffer_thread;
		_new = malloc(1);
		*_new = _temp;
		if( pthread_create( &sniffer_thread , NULL ,  evaluate , ( void *) _new) < 0) {
			printf( AETHER_ERROR , "les :: init" , "Thread cannot be created" );
			return 2;
		}
		num_threads += 1;
	}
	if ( _temp < 0 ) {
		printf( AETHER_ERROR , "les :: init" , "Listener could not accept connection" );
		return 2;
	}
	return 0;
}
