
#ifndef __IXR__H
#define LOG_ERR 1
#define OUTPUT 1
#include "ixr.h"
#endif


#ifndef __ixr_name 

	//expanding args
	#define ixr_mem 	((void *)&___header.head)
	#define ixr_ubuf	((uchar *)&___header.head)
	#define ixr_buf		((char *)&___header.head)
	#define ixr_head	((char const *)&___header.head)
	#define ixr_h_args ___header.__size, ___header.d_count, ___header.checksum
	#define __eixrh(x) x->__size, x->d_count, x->checksum
	#define __ihsz(x) x->__size
	// unistd flags for `open`&`creat`
	#define __ixr_start_flags (O_RDWR|O_APPEND|O_CREAT|O_EXCL|O_NOFOLLOW_ANY)
	#define __ixr_access_flags (O_RDWR|O_NOFOLLOW_ANY)
	#define __ixr_pmode (S_IRWXU|S_IXGRP|S_IXOTH)

	/********* files *********/

	ulong __fsize(char const *__fpath){
		struct stat __;
		memset(&__,0,sizeof(struct stat));
		if(stat(__fpath,&__)!=0){return 0;}
		return __.st_size;
	};

	ulong __iosize(char const *__fpath){
		struct stat __;
		memset(&__,0,sizeof(struct stat));
		if(stat(__fpath,&__)!=0){return 0;}
		return __.st_blksize;
	};

	ulong __inodenum(char const *__fpath){
		struct stat __;
		memset(&__,0,sizeof(struct stat));
		if(stat(__fpath,&__)!=0){return 0;}
		return __.st_ino;
	};

	uns __dmode(char const *__fpath){
		struct stat __;
		memset(&__,0,sizeof(struct stat));
		if(stat(__fpath,&__)!=0){return 0;}
		return __.st_mode;
	};

	ulong __file_r(char const *__cpath){
		if (access(__cpath,R_OK)==0){
			return 1;
		}
		return 0;
	};

	ulong __file_w(char const *__cpath){
		if (access(__cpath,W_OK)==0){
			return 2; 
		}
		return 0;
	};

	ulong __file_x(char const *__cpath){
		if (access(__cpath,X_OK)==0){
			return fsze(__cpath);
		}
		return 0;
	};

	char const *__getcaller(){

		return (char const *)__FILE__;
	};


	/********* d-types *********/

	dpoint_t ref_point(void const *__arg, char const *__key, char const *__format) {
		if(__key[0]=='&') {
			++__key;
		};
		ulong keylen=str_rwings(__key);
		dpoint_t __point; memset(&__point, 0, size_dpoint_t);
		ulong packedlen=__ixr_argument(__format, __arg);
		#ifdef DEBUG
			printf("packed length :: %lu\n", packedlen);
		#endif
		__point.c_index=__cindex;
		__point.c_name=__key;
		__point.c_ref=__arg;
		__point.d_fmt=__format;

		return __point;
	};

	char const *ixr_format(ixr_t idx_type) {
		switch(idx_type) {
		case ixr_header:	return __head_fmt;
		case ixr_point:		return __value_fmt;
		case ixr_file:		return __file_fmt;
		case ixr_dprg:		return __dprg_fmt;
		case ixr_fld:		return __fld_fmt;
		default: return NULL;
		};
	};

	char const *ixr_address(void *cis_ixr, ixr_t ixr_type) {
	
		return NULL;
	};

	char const *__kaddress(char const *__hash) {
	    ulong __len=str_rwings(__hash)+3;
	    char temp[__len];memset(&temp, 0, sizeof(temp));
	    temp[0]='k';
	    switch((__len-3)) {
	    case 8:  temp[1]='C'; break; // command 
	    case 16: temp[1]='I'; break; // interpreter
	    case 32: temp[1]='P'; break; // payload
	    default: temp[1]='-'; break; // K-address
	    };
	    memmove((temp+2), __hash, __len);
	    temp[__len]='\0';
	    return (char const *)strdup(temp);
	};

	void *__erv(char const *__key,char const *__val) {
		ulong __sz=str_rwings(__key)+str_rwings(__val)+5;
		ulong __len=len_ustrze(__sz);
		void *__=malloc(__len);
		memset(__, 0, __len);
		uns psz=pack(__, ixr_format(ixr_point), __cindex, __key, __val);
		return __;
	};

	ulong __set_next_p(void *__) {
		ulong retres=__set_next((char const *)(__));
		free(__);
		return retres;
	};

	char const *__generic_fmt(fmt_t __format, ...) {

		return NULL;
	};

	uchar const *__urv(uchar const *__key, char const *__value) {
		char const *__rv=__generic_fmt(__keyval__, __key, __value);
		ulong urv_len=__rwings((void *)__rv)+ULONG_MAX_DIGITS;
		char urv[urv_len];memset(&urv, 0, sizeof(urv));
		sprintf(urv, "%lu:%s", __cindex, __rv);
		return (uchar const *)strdup(urv);
	}

	// irv
	char const *__irv(char const *__key, char const *__value) {
		char const *__rv=__generic_fmt(__keyval__, __key, __value);
		ulong irv_len=str_rwings(__rv)+ULONG_MAX_DIGITS;
		char irv[irv_len];memset(&irv, 0, sizeof(irv));
		sprintf(irv, "%lu:%s", __cindex, __rv);
		return (char const *)strdup(irv);
	};

	// increment the cindex
	ulong __index_increment() {
		__cindex+=1;
		return __cindex;
	};
	
	// set the next header at a new entry
	ulong __set_next(char const *__head){
		ulong __len=str_rwings(__head);
		if((__head==NULL)||__len==1){
			return 0;
		};
		long _res=pwrite(__ixr_fd,__head,__len,___offset);

		if(_res!=-1){
			___offset+=__len;
		};
		#ifdef DEBUG
			printf("\nnext -->\n");
			printf("head   :: %s\n", __head);
			printf("length :: %lu\n", __len);
			printf("result :: %ld\n", _res);
			printf("offset ::: %lu\n", ___offset);
		#endif
		return __index_increment();
	};
	

	// start the indexer
	ulong __idx_start(){
		if(__cindex!=0){
			return 0;
		};
		return __index_increment();
	};
	

	// create a xreference for the current indexer
	char const *__xreference(char const *__) {

		return hashof(1,(void *)__,str_rwings(__));
	};
	

	// generic fmt -> xreference -> setnext
	int __index_r(char const *idxnr) {
		char const *_rfmt=__generic_fmt(__keyval__,  __xreference(idxnr), idxnr);
		return __set_next(_rfmt);
	};
	

	// irv -> __setnext -> (key, val)
	int __index_irn(char const *key, char const *val) {

		return __set_next(__irv(key, val));;
	};
	

	// irv -> __setnext -> (key, __xreference)
	int __index_ixn(char const *key) {

		return __index_irn(key, __xreference(key));
	};
	

	// irv -> __setnext -> (__xreference, caller)
	int __index_caller() {
		char const *caller=__getcaller();
		return __index_irn(__kaddress(__xreference(caller)), caller);
	};
	

	ulong __set_unext(uchar const *__head){
		ulong __len=__rwings(__head);
		if((__head==NULL)||__len==1){
			return 0;
		};
		long _res=pwrite(__ixr_fd,__head,__len,___offset);

		if(_res!=-1){
			___offset+=__len;
		};
		#ifdef DEBUG
			printf("\nnext -->\n");
			printf("head   :: %s\n", __head);
			printf("length :: %lu\n", __len);
			printf("result :: %ld\n", _res);
			printf("offset ::: %lu\n", ___offset);
		#endif
		return __index_increment();
	}


	int __index_urn(uchar const *_key, char const *_val) {

		return __set_unext(__urv(_key, _val));
	};

	// irv -> __setnext -> (reference, name)
	int __index_point(dpoint_t *dst) {

		return __index_urn(dst->c_ref, dst->c_name);
	};

	/********* indexer IO *********/

	// initiate and set memory to zero for the header struct
	void *__header__() {
		return memset(&___header, 0, sizeof(ixr_h));
	};

	// read the indexer header \\
	OFFSET ALWAYS 0
	int __header_in() {

		return 0;
	};

	int __load_header() {
		__header__();
		#ifdef PROCESS
			printf("read :::");
		#endif
		uchar *__head=ixr_ubuf;
		unsigned __rbytes=pread(__ixr_fd, (void *)__head, __I_LEN, 0);
		if (__rbytes==-1) {
			#ifdef LOG_ERR
				printf("%s : err :: cannot write header to indexfile ::: %d\n", __FILE__, errno);
			#endif
			return -1;
		};
		#ifdef DEBUG
			printf("read %d bytes for idx header\n", __rbytes);
		#endif
		__head[__I_LEN-1]='\0';
		unpack(__head, ixr_format(ixr_point), __rbytes);
		___header.__size=u[0];
		___header.d_count=u[1];
		___header.checksum=u[2];
		___offset=(ulong)__rbytes;
		#ifdef DEBUG
			printf("attempting %d @indexfile: %lu\n", __tempres, __hfsize);
			log_ixrh(&___header);
		#endif	
		return __header_in();
		return 0;		
	}

	int __rd_ixrh() {
		#ifdef DEBUG
			printf("reading :::\n");
		#endif
		uchar __head[29];ulong __hsz=sizeof(__head);memset(&__head, 0, __hsz);
		ulong __hfsize=fsze(__lbb_indexfile);
		if(__hfsize<__hsz) {
			__hsz=__hfsize;
		};
		int __tempres=pread(__ixr_fd, (void *)__head, __hsz, 0);
		if(__tempres==-1) {
			#ifdef LOG_ERR
				printf("cannot read header\n");
			#endif
			return -1;
		};
		unpack(__head, ixr_format(ixr_point), ixr_h_size(___header));
		___header.__size=u[0];
		___header.d_count=u[1];
		___header.checksum=u[2];
		___offset=(ulong)__tempres;
		#ifdef DEBUG
			printf("attempting %d @indexfile: %lu\n", __tempres, __hfsize);
			log_ixrh(&___header);
		#endif
		return 0;
	};


	// write the indexer header \\
	OFFSET ALWAYS 0
	int __header_out(uchar *__header_content, ulong __header_size) {
		if(__header_size>__I_LEN){
			#ifdef LOG_ERR
				printf("cannot pack more than 64 bytes in the header\n");
			#endif
			return -1;
		};
		int __bytes_w=pwrite(__ixr_fd, (void *)__header_content, __header_size, 0);
		if(__bytes_w==-1){
			#if LOG_ERR
				printf("%s : err :: cannot write header to indexfile ::: %d\n", __FILE__, errno);
			#endif
			return -1;
		};
		#ifdef DEBUG
			printf("wrote %d bytes for idx header\n", _temp);
		#endif
		___offset=(ulong)__bytes_w;
		return 0;
	};

	int __write_header() {
		#ifdef PROCESS
			printf("writing :::");
		#endif
		uchar __head[__I_LEN];memset(&__head, 0, sizeof(__head));
		unsigned __temp=pack(__head, ixr_format(ixr_header), ixr_h_args);
		__head[__I_LEN-1]='\0';
		__header_out(__head, __temp);
		#ifdef DEBUG
			printf("packed %d bytes for idx header\n", __temp);
		#endif
		return 0;
	};



	// obtain header properties { ENVIROMENT }
	int __refresh_header() {
		___header.__size=fsze(__lbb_indexfile);
		___header.d_count=__cindex;
		___header.checksum=fhash16(1, __lbb_indexfile);
		return 0;
	}
	// check if header exsits then retain 
	// new header properties
	int refresh_h() {
		if(!__stres(__lbb_indexfile)) {
			#ifdef LOG_ERR
				printf("indexfile does not exist\n");
			#endif
			return 1;
		};
		return __refresh_header();
	};


	// start the indexer 
	int indexer_start() {
		// if the indexer has not been instantiated but has
		// a different value than the original constant
		if(__ixr_fd!=0x228){
			#ifdef LOG_ERR
				printf("trying to instantiate indexer that is not on %d", 0x228);
			#endif
			return -1;
		};
		if(__stres(__lbb_indexfile)) {
			#ifdef LOG_ERR
				printf("indexer already exists\n");
			#endif
			return -1;
		};
		__header__();
		int ixr_fd=-1;
		ixr_fd=open(__lbb_indexfile, __ixr_start_flags, __ixr_pmode);
		if(ixr_fd==-1){
			#ifdef LOG_ERR
				printf("indexer fd failed on create\n");
			#endif
			return -1;
		};
		__ixr_fd=(ulong)ixr_fd;
		#ifdef DEBUG
			printf("Indexer started ::: %lu\n",__ixr_fd);
		#endif
		__refresh_header();
		if(__write_header()) {
			#ifdef LOG_ERR
				printf("cannot write indexer header\n");
			#endif
			return -1;
		};
		#ifdef DEBUG
			printf("@offset %lu\n",___offset);
		#endif
		return 0;
	};


	// index any incoming idrs
	int __indexer__(char const *idr) {
		if(idr==NULL){
			#ifdef LOG_ERR
				printf("requested to index NULL\n");
			#endif
			return -1;
		};
		if(__ixr_fd==0x228) {
			int ixr_fd=-1;
			ixr_fd=open(__lbb_indexfile, __ixr_access_flags, __ixr_pmode);
			if(ixr_fd==-1){
				#ifdef LOG_ERR
					printf("Cannot open indexer file\n");
				#endif
				return -1;
			};
			__ixr_fd=(ulong)ixr_fd;
			#ifdef DEBUG
				printf("Parsing index file :: %s\n", __lbb_indexfile);
				printf("file descriptor :open::%d\n",ixr_fd);
			#endif
		};
		__header__();
		if(__rd_ixrh()) {
			#ifdef LOG_ERR
				printf("cannot read indexer header\n");
			#endif
			return -1;
		};
		#ifdef DEBUG
			printf("@offset %lu\n",___offset);
		#endif
		return 0;
	};


	int refer_index(void *__ptr, void *__ref, char *__prname) {
		char *rname=(char *)__ref;
		if(__exact_match(rname, __prname)) {
			printf("exact match\n");
		};

		printf("ptr  : %p\n", __ptr);
		printf("lbbr : %p\n", __ref);
		printf("ref  : %s\n", rname);
		printf("name : %s\n", __prname);
		return 0;
	};
	

    ulong __ixr_argument(char const *__format, void const *__) {
    	char const arg_fmt=__format[0];
    	memset(pbuf, 0, sizeof(pbuffer));
    	ulong ps=0;

    	switch(arg_fmt) {
    	case 's': ps=pack(pbuf, __format, (char *)__); break;
    	case 'h': ps=pack(pbuf, __format, (int *)__); break;
    	case 'H': ps=pack(pbuf, __format, (uns *)__); break;
    	case 'l': ps=pack(pbuf, __format, (long*)__); break;
    	case 'L': ps=pack(pbuf, __format, (ulong*)__); break;
    	case 'Q': ps=pack(pbuf, __format, (tlong*)__); break;
    	case '_': ps=pack(pbuf, __format, (void *)__); break;
    	default: return 0;
    	};
    	return ps;
    };


	void log_ixr_point(void *__) {
		printf("point index 	: %lu\n",ist_index(__));
		printf("point reference : %s\n", ist_ref(__));
		printf("point name  	: %s\n", ist_name(__));
	};

	// log indexer prototype
	void log_ixrh(ixr_h *ixrh) {
		printf("\nindexer head ::\n");
		printf("\tfldsze=%lu", ixrh->__size);
		printf("\tdcount=%lu", ixrh->d_count);
		printf("\tchksum=%lu", ixrh->checksum);
		printf("\n");
	};



	#define __ixr_name "indexer"
#endif