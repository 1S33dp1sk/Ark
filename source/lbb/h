#ifndef __LBB__H
	#include "utypes.h"
	#include "standard.h"
	#define __lbb_c_regex "\\(^[a-zA-Z0-9]*\\)[=:]\\{1,\\}\\([a-zA-Z0-9]*\\)$"
	#define __lbb_mode__ (S_IRWXU|S_IRWXG|S_IRWXO)
	#define __lbb_shard_flags (O_RDWR|O_APPEND|O_CREAT|O_EXCL|O_NOFOLLOW_ANY)
	#define __lbb_lock_reader (O_RDONLY)
	#define __lbb_lock_writer (O_WRONLY)
	#define __lbb_lock_new (O_RDWR|O_CREAT|O_EXCL)
	#define __lbb_default_flags (S_IRUSR|S_IWGRP|S_IWOTH)
	#define __lbb_share_flags (O_RDONLY)
	#define __lbb_private_mode (S_IRWXU|S_IXGRP|S_IXOTH)
	#define __lbb_share_mode (S_IRWXU|S_IWGRP|S_IXGRP|S_IWOTH|S_IXOTH)
	#define __lbb_public_mode (S_IRUSR|S_IXUSR|S_IRGRP|S_IXGRP|S_IROTH|S_IXOTH)

	unsigned int pack(uchar *buf,char const *fmt,...);
	char const *hashof(unsigned level, void const *to_hash, ulong hash_size);
	char const *fhashof(unsigned level, char const *file_path);
	void unpack(uchar *buf,char const *fmt,...);
	void __closeb();

	int __stres(char const* cpath);
	uns __8sz(uns __);
	uns __dmode(char const *__cpath);
	ulong __fsize(char const *__cpath);
	ulong __iosize(char const *__cpath);
	void *__statusof(char const *__cpath);
	int __ap_fifo(char const *__cpath);

	int lbb(char const *__cpath, ulong __lockfd);
	ulong write_book(char *__contents, ulong __c_size);
	ulong start_book();
	ulong lbb_print(char *k__addr);
	ulong reset_book();
	char *read_book();
	void lbb_close();

	int spaces_and_tabs(char *__string);
	char *str_b4offset(char const *__string, ulong __offset);
	char *str_a4offset(char const *__string, ulong __offset);
	char *str_a4woffset(char const *__string, ulong __offset);
	ulong sep_offset(char const *string,char *seperator);
	spstr sepstr_offset(char *__string, char *__seperator);
	strld extract_atoff(char *__string, ulong __offset);
	char const *__combine_str(char const *str1, char const *str2);

	int get_kstat(char const *__path, k_stat *kfile);
	int get_sstat(char const *__path, s_stat *sfile);
	int get_mstat(char const *__path, m_stat *mfile);

	void log_mstat(m_stat *mfile);
	void log_sstat(s_stat *sfile);
	void log_kstat(k_stat *kfile);
	void log_str(strld __strld);
	void log_sepstr(spstr __spstr);
	void log_ptrdx(struct __ptrdx *ptrdx);
	void log_esptr(ulong *esptr);
	void log_process_ids(ulong ppid, ulong cpid);
	void log_process_schema(ulong ppid, ulong cpid);

	ulong str_rwings(char const *__);

	/**
	** NNE : x :: true if x is not 0x0000
	**/
	#define NNE(v) v==0x0000?0x01:0x00
	// call result sucessful 
	#define CALL_SUCC(x) x==(ulong)0?1:0
	// call result instantiate
	#define CALL_INST(x) x==(ulong)1?1:0
	// call result not sucessful
	#define CALL_NSUC(x) x==(ulong)-1?1:0
	// call result jump
	#define CALL_NEXT(x) x<(ulong)-1?x>(ulong)1?1:x:0

	#define __dPER while(1!=1);

	static const ulong size_fld=sizeof(fld);
	static ulong ___lbb_offset=0;
	
	// printf friendly
    #define FMT_ASCII_SPEC(__) _Generic((__), \
                                            int: "%d",\
                                            uns: "%u",\
                                            char: "%c",\
                                            long: "%ld",\
                                            ulong: "%lu",\
                                            tlong: "%llu",\
                                            char *: "%s",\
                                            char const *:"%s",\
                                            long long: "%lld",\
                                            default: "%x")

    #define LBB_FMT_SPEC(lbb_type) _Generic((lbb_type), \
    	ixr_h: "%lu bytes\n %lu@%lu dpoints\n head : %s\n",\
    	default: "no lbb_type matched\n"\
    )

    #define LBB_SPEC(lbb_arg) _Generic((lbb_arg), \
    	ixr_h*: &ixrh_size(lbb_arg), ixrh_dcount(lbb_arg), ixrh_checksum(lbb_arg), ixrh_head(lbb_arg),\
	    default: NULL\
    )

    #define lbb_indexer_address indexer_header()
    #define lbb_bytes_shared 1200

    #define LBB_GET(a) __OUT_ASCII(0, lbb_##a)
    #define IXR_GET(a, type) (type *)lbb_##a 

    // #define LBB_EVAL(type, varname) LBB_FMT_OUT(0, type, varname)

    #define IXR_OUT(fd, type, val) do {\
        printf("%d@lbb<%s>(%s)\n", fd, #type, #val);\
	} __dPER

    #define LBB_OUT(fd, mthd, valu) do {\
    	printf("%d@lbb<%s>{%s}\n", fd, mthd, #valu);\
	} __dPER

    #define _OUT_ASCII(fd,x) do { \
    	ulong len=str_rwings(x);\
        long ws=write(fd,x,len);\
    	printf("lbb@<fd:%lu>(%lu) {%s} = \n", fd, len, x, ws);\
    } __dPER

   #define OUT_ASCII(fd,x) do { \
    	ulong len=str_rwings(#x);\
    	long ws=pwrite(fd,#x,len,___lbb_offset);\
    	if(ws>0){ ___lbb_offset += ws; };\
        printf("%ld@lbb<w>{ %s } \n", ws, #x);\
    } __dPER

 	#define __OUT_ASCII(fd,x) do { \
    	ulong len=str_rwings(#x);\
    	long ws=pwrite(fd,#x,len,___lbb_offset);\
    	if(ws>0){ ___lbb_offset += ws; };\
    	LBB_OUT(0, #x, x);\
    } __dPER


	#define PACK_IN(fld,siz,fmt,...) do {\
	    uchar __[siz];memset(&__,0,siz);\
	    ulong sz=(ulong)pack(__,fmt,#__VA_ARGS__);\
	    printf("\n\n\n\n\npacking size :: %lu", sz);\
	    write(fld,__,sz);\
	} __dPER

	#define pth_shard(x) ((char *)((x.lbb_mst).m_path))
	#define fld_shard(x) ((ulong)(x.lbb_fd))
	#define sze_shard(x) ((ulong)((x.lbb_mst).m_size))
	#define ioz_shard(x) ((ulong)((x.lbb_mst).m_blksz))

	#define shd_fd fld_shard(lbb_shard)
	#define shd_sze sze_shard(lbb_shard)
	#define shd_io ioz_shard(lbb_shard)
	#define shd_path pth_shard(lbb_shard)
	#define shd_key hashof(1,lbb_mstat,sizeof(m_stat))

	#define checkef_file ((ulong)__stres(__lbb_indexfile))
	#define checkef_dir ((ulong)__stres(__lbb_convdir))
	#define checkef_lo ((ulong)__stres(__lbb_locking))

	#define inodenum ((ulong)(lbb_mstat->m_inn))
	#define ifilesize ((ulong)(lbb_mstat->m_size))
	#define idmode ((ulong)(lbb_mstat->m_mode))
	#define iblkio ((ulong)(lbb_mstat->m_blk))

	#define __NOT_FOUND "Not-Found \xE2\x9C\x95"
	#define __FOUND "Found \xE2\x9C\x93"
	#define FND_NTFND(x) x==0?__NOT_FOUND:__FOUND

static lshard lbb_shard;
static lshard *l_shard=&lbb_shard;
static m_stat *lbb_mstat=&(lbb_shard.lbb_mst);

	
	#define __BASE__ {\
		static char dbuf[__A_LEN];memset(&dbuf, 0, sizeof(dbuf));\
		memset(lbb_mstat, 0, sizeof(struct __m_stat));\
		memset(l_shard,0,sizeof(struct __lbb_shard));\
		printf("getting shard .:%s:. \n",__lbb_indexfile);\
		if(!checkef_file){INDEXER(NULL);}\
		get_mstat(__lbb_indexfile,lbb_mstat);\
	}
	#define __TYPD__(d) {\
		__BASE__\
		printf("sizeof type-d : %lu\n",sizeof(d));\
	}
	#define __DPRG__ do __BASE__ __dPER
	#define __LBB__(rx,vx) {\
		__BASE__\
		if(vx==NULL){R_INDEXER(rx,&rx);}\
		else {R_INDEXER(rx,vx);};\
	}
	#define __ARGS__ {\
	
	#define __dRUN(x,a) __dPRG __ARGS__ &x 
	#define __dLBB(x) __LBB_START__(&x,#x)
	#define d(...) __dLBB(#__VA_ARGS__)

	#define __LBB_START__ __DPRG__

	#define __LBB_WRITER__ do {\
		memset(l_shard,0,sizeof(struct __lbb_shard));\
		w_start_ap();\
	} __dPER

	#define LBB_INFO do{\
		printf("Linked Binary Book {a.k.a %s}\n","lbb");\
		printf("book:home  ::  lbb/  ::: %s\n",FND_NTFND(checkef_dir));\
		printf("book:lock  ::  lock  ::: %s\n",FND_NTFND(checkef_file));\
		printf("book:tern  ::  .lbb  ::: %s\n",FND_NTFND(checkef_lo));\
	} __dPER

	#define __LBB_READER__ do{\
		memset(l_shard,0,sizeof(struct __lbb_shard));\
		if(!checkef_lo) {__ap_fifo(__lbb_locking);};\
		r_start_ap();\
	} __dPER

	#define __lbb_buffer_size 512
	#define LBB_BUFFER_SIZE ((ulong)__lbb_buffer_size)

	#define __LBB__H 1
#endif
