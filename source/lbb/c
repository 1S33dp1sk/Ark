/// lbb \\\
little black book

#ifndef __LBB__H
#include "lbb.h"
#endif

#define OUTPUT 1
#define LOG_ERR 1

#ifndef __os_name
#define __os_delim "/"
	#if HAVE_TARGET_CONDITIONALS_H
		#include <targetConditionals.h>
	#endif
	#if _WIN64
		#define __os_name "windows:64b\0"
		#undef __os_delim
		#define __os_delim '\\'
	#elif _WIN32
		#define __os_name "windows\0"
		#undef __os_delim
		#define __os_delim "\\"
	#elif defined(TARGET_OS_IPHONE)
		#define __os_name "apple:iphone\0"
	#elif defined(TARGET_OS_MAC)
		#define __os_name "apple:macos\0"
	#elif __APPLE__!=0
		#define __os_name "apple\0"
	#elif __linux__!=0
		#define __os_name "unix:linux\0"
	#elif __ANDROID__!=0
		#define __os_name "unix:android\0"
	#elif BSD
		#define __os_name "bsd\0"
	#elif __unix__
		#define __os_name "unix\0"
	#else
		#define __os_name "\0"
	#endif
#endif


#ifndef __lbb_name
	#define __lbb_name "linked binary book"




// try to create a { SHARED } file
// get the mounted status of said file
// load into `lbb_shard`
int __ap_file(char const *__path){
	int __fd=open(__path,__lbb_shard_flags);
	if(__fd==-1){
		#ifdef LOG_ERR
			printf("cannot create share file, %s\n", __path);
		#endif
		return __fd;
	}
	lbb_shard.lbb_fd=__fd;
	if(get_mstat(__path, lbb_mstat)) {
		#ifdef LOG_ERR
			printf("cannot get the mounted status of file %s\n", __path);
		#endif
		return -1;
	};
	return __fd;
};

// try to create an FIFO engine 
int __ap_fifo(char const *__path){
	if(mkfifo(__path,__lbb_mode__)==0){
		return 1;
	}
	return -1;
};

// try to open a previously created
// engine as a writer, this can be any
// socket connections or commands , etc..
ulong __ap_writer() {
	ulong retres;
	int __fd=open(__lbb_locking,__lbb_lock_writer);
	if(__fd==-1){
		#ifdef LOG_ERR
			printf("cannot open writer\n");
		#endif
		retres=0;
		_exit(2);
	};
	ulong _fd=(ulong)__fd;
	#ifdef DEBUG
		printf("Writer : fifo opened :: %lu\n",_fd);
	#endif
	lbb_shard.lbb_fd=_fd;
	if(get_mstat(__lbb_locking, lbb_mstat)) {
		#ifdef LOG_ERR
			printf("cannot obtain mounted status for Writer on FIFO\n");
		#endif
		_exit(1);
	}
	return _fd;	
};

// try to open a recently created engine \
MUST NOT HAVE ANY LOCKING BITS
ulong __ap_reader() {
	ulong retres=0;
	int __fd=open(__lbb_locking,__lbb_lock_reader);
	if(__fd==-1){
		printf("cannot open reader\n");
		_exit(1);
	};
	ulong _fd=(ulong)__fd;
	#ifdef DEBUG
		printf("Reader : fifo opened :: %lu\n",_fd);
	#endif
	lbb_shard.lbb_fd=_fd;
	if(get_mstat(__lbb_locking, lbb_mstat)) {
		#ifdef LOG_ERR
			printf("cannot obtain mounted status for READER on FIFO\n");
		#endif
		_exit(2);
	};
	return _fd;
};

ulong __lbb_file_r(char const *__fpath) {
	ulong retres=0;
	int __fd=open(__fpath,__lbb_lock_reader);
	if(__fd==-1){
		#ifdef LOG_ERR
			printf("cannot open reader\n");
		#endif
		_exit(1);
	};
	retres=(ulong)__fd;
	#ifdef DEBUG
		printf("Reader : fifo opened :: %lu\n",retres);
	#endif
	return retres;
};

ulong __lbb_file_w(char const *__fpath) {
	ulong retres=0;
	int __fd=open(__fpath,__lbb_lock_writer);
	if(__fd==-1){
		#ifdef LOG_ERR
			printf("cannot open reader\n");
		#endif
		_exit(1);
	};
	retres=(ulong)__fd;
	#ifdef DEBUG
		printf("Reader : fifo opened :: %lu\n",retres);
	#endif
	return retres;
};

#define LOG_ERR 1
ulong __lbb_file_n(char const *__fpath) {
	ulong retres=0;
	ulong temp=str_rwings(__fpath), __total=temp;
	__total+=str_rwings(__FILE__);
	ulong __offset_f=sep_offset(__fpath, "@charms");
	ulong __offset_p=sep_offset(__FILE__, "@charms")+1;

	char const *__=__combine_str(str_b4offset(__FILE__, __offset_p), str_a4woffset(__fpath, __offset_f));

	printf("__ ::: %s\n", __);

	if((__offset_f)) {
		#ifdef LOG_ERR
			printf("cannot obtain dual offset\n");
		#endif
		_exit(2);
	};

	int __fd=open(__,__lbb_shard_flags);
	if(__fd==-1){
		#ifdef LOG_ERR
			printf("cannot open reader\n");
		#endif
		_exit(1);
	};
	retres=(ulong)__fd;
	#ifdef DEBUG
		printf("shard : file opened :: %lu\n",retres);
	#endif
	return retres;
};


// close the lbb filedescriptor currently
// opened under the lbb_shard structure
void purge_shard() {
	#ifdef DEBUG
		printf("Purging lbb shard\n");
	#endif
	close(lbb_shard.lbb_fd);
};


ulong __run_ap(ulong __size){
	if(__size>=512){
		ulong r_bytes=0,__FLAG=0;
		char __buffer[512];
		while(!__FLAG) {
			r_bytes=read(lbb_shard.lbb_fd,__buffer,512);
			if(r_bytes<=2){
				printf("read less than 3 bytes :: %s\n",__buffer);
				__FLAG=1;
			};
			r_bytes=0;memset(&__buffer,0,sizeof(__buffer));
		};
		purge_shard();
		return __FLAG;		
	}
	else {
		ulong w_bytes=0,__FLAG=0;
		char *__buffer="hello world";
		memset(&__buffer,0,sizeof(__buffer));
		while(!__FLAG) {
			w_bytes=write(lbb_shard.lbb_fd,__buffer,64);
			if(w_bytes<=2){
				printf("write less than 3 bytes :: %s\n",__buffer);
				__FLAG=1;
			};
			w_bytes=0;memset(&__buffer,0,sizeof(__buffer));
		};
		purge_shard();
		return __FLAG;				
	}
};


/*******************************************************************/


ulong __writeb(uchar *content,ulong c_size) {
	ulong __fd=shd_fd;
	if(__fd!=0){
		ulong _size = (ulong)write(__fd,content,c_size);
		#ifdef DEBUG
			printf( "resof write :: %lu\n",_size);
		#endif
		return _size;
	}	
	return 0;
};

int __dgetfd(char *__fpath) {
	return open(__fpath, __lbb_lock_reader);
};

char *__readb(ulong f_size, ulong f_d,ulong r_o){
	ulong __res=r_o,__fsz=f_size,__fd=f_d;
	uchar lbb_content[__fsz+1];
	int __tempres=read(__fd,lbb_content,__fsz);
	if(__tempres==-1){
		printf("cannot read lbb\n");
		return NULL;
	};
	__res=(ulong)__tempres;
	lbb_content[__fsz+1]='\0';
	if((__res<__fsz)&&(__res>0)){
		// means that reading was interuptted
		// for some reason, like a pipe or sig
		// so we can read from where we left off
		__res=pread(__fd,(lbb_content+__res),(__fsz-__res),__res);
	};
	return strdup((char*)lbb_content);
};

void __readin(char *buffer, ulong size, ulong stfd) {
	ulong __res=0,__fsz=size,__fd=stfd;
	int __tempres=0;
	do {
		__tempres=pread(__fd, (buffer+__res), (__fsz-__res), __res);
		__res+=__tempres>0?__tempres:0;
	}while(__tempres!=0);
	buffer[__fsz]='\0';
};

ulong __fillb(){ // create &-> fill the book
	ulong __res=__writeb((uchar*)shd_key,LBB_BUFFER_SIZE);
	lbb_close();
	return __res;
};



ulong write_book(char *content, ulong csize) {

	return __writeb((uchar*)content,csize);
};

char *read_book(char *__bpath){ 
	m_stat cm_st;
	int res=get_mstat(__bpath, &cm_st);
	if(res!=0){
		return NULL;
	}
	return __readb(cm_st.m_size, __dgetfd(__bpath), 0);
};

void lbb_close(){
	close(shd_fd);
	memset(&lbb_shard,0,sizeof(struct __lbb_shard));
};

ulong reset_book(){

	return __fillb();
};

ulong lbb_print(char *kaddr){
	ulong res=__writeb((uchar *)kaddr,str_rwings(kaddr));
	return res;
};

int lbb(char const *__cpath,ulong __lock){
	ulong res=0;
	#if defined(locked)
		SET_LBB_PATH(__cpath);
		SET_LBB_FD(__lock);
	#endif
	char *LOCKING="locked\n";
	__writeb((uchar *)LOCKING,str_rwings(LOCKING));
	lbb_close();
	return res;
};



/*******************************************************************/


struct __ptrdx __iptridx(char const *__ptr_index) {
	char *_ptr_idx=(char *)__ptr_index;

	ulong plen=str_rwings(_ptr_idx);
	ulong lcount=0;

	ulong off_at=sep_offset(_ptr_idx,"ae");

	char *_pidx=str_b4offset(_ptr_idx,off_at);
	ulong pidx,_pxlen=str_rwings(_pidx);
	uchar *pidx_=(uchar *)_pidx;
	unpack(pidx_,"L",pidx);


	char *_tri=str_a4offset(_ptr_idx,off_at);
	ulong tri,_tilen=str_rwings(_tri);
	uchar *tri_=(uchar *)_tri;
	unpack(tri_,"L",tri);

	struct __ptrdx ipd;
	memset(&ipd,0,sizeof(struct __ptrdx));
	ipd.pidx=pidx;
	ipd.tri=tri;

	return ipd;
};

void *___exsptr(char const *__ptr_index) {
	ulong lcount=0, lcpy=0, plen=str_rwings(__ptr_index), comb_len=plen;
	char *_ptr_idx=(char *)__ptr_index;
	uchar *__pind=(uchar *)_ptr_idx;

	while(comb_len>8){
		lcount+=1;comb_len-=8;
	};

	// ulong esize=lcount*(sizeof(ulong));
	// void *_es_ptrs=malloc(esize);
	// _es_ptrs=memset(_es_ptrs,0,esize);

	// ulong *es_ptr=(ulong *)_es_ptrs;

	// es_ptr[0]=1281;
	// es_ptr[1]=28589105;

	// // while(lcpy<(lcount-1)){
	// // 	unpack(__pind,"L",es_ptrs[lcpy]);
	// // 	lcpy+=1;
	// // };
	// // es_ptrs[lcount]='\0';

	// // // log_esptr()
	// // return es_ptrs;


	return (void *)__ptr_index;
};

spstr sepstr_offset(char *string, char *seperator) {
	int x=0,y=0,len_count=0,offset_at=-1;
	while(string[x]!='\0'){
		if(string[x]==seperator[y]){
			while(seperator[y]==string[y+x]){
				y+=1;
			};
			if(seperator[y]=='\0'){
				offset_at=x;
			}
			else{
				y=0;
			};
		};
		x+=1;
	};
	struct sepstr res = {
		.str=string,
		.str_length=x,
		.sep=seperator,
		.sep_offs=offset_at,
	};
	return res;
};

/**
 * extract the string at offset
**/
strld extract_atoff(char *str, ulong atoff){
	strld res;
	res.data=str+atoff;
	char *s=str+atoff;
	int c=0;
	while(*s++){
		c+=1;
	};
	res.len=c;
	return res;
};


/*******************************************************************/


void test_spaces_and_tabs() {
	int spta_count=spaces_and_tabs(" aksd foa	sf");
	printf("spaces+tabs count :: %d\n",spta_count);
};

void test_init_sepstr(char const*fullstr, char const*sep) {
	struct sepstr res;
	if(fullstr==NULL||sep==NULL){
		res=sepstr_offset("mykey:has a very niceth=ce value of ", "=c");
	}
	else {
		res=sepstr_offset((char *)fullstr,(char *)sep);
	};

	log_sepstr(res);
};

/*******************************************************************/


int main_sepstr(int argc, char const *argv[]){
	if(argc==3){
		test_init_sepstr(argv[1],argv[2]);
	}
	else{
		test_init_sepstr(NULL,NULL);
	}
	return 0;
};

int main_atoff(){
	strld sep=extract_atoff("hello world\n",6);
	log_str(sep);
	return 0;
};


/*******************************************************************/


int get_sstat(char const *__path, s_stat *sfile) {
	memset(sfile,0,sizeof(s_stat));
	ulong path_len=str_rwings(__path);
	if(path_len>512){
		return -1;
	};
	memmove(sfile->s_path,__path,path_len);
	char *_path=(char *)__path;
	ulong off_at=sep_offset(_path,"@");
	if(off_at==0){
		return -1;
	};
	#if DEBUG
		printf("offset of @ is %lu characters\n", off_at);
	#endif

	char *faddr=str_b4offset(_path,off_at);
	sfile->sa_len=str_rwings(faddr);

	char *fipat=str_a4offset(_path,off_at);
	sfile->se_len=str_rwings(fipat);

	memmove((&sfile->s_addr),faddr,sfile->sa_len);
	memmove((&sfile->s_ipv),fipat,sfile->se_len);

	if(fipat==NULL){
		return -1;
	}

	if(sfile->sa_len>8){sfile->s_term=Public;}else{ sfile->s_term=Private;}

	return 0;
};

int get_kstat(char const *__path, k_stat *kfile) {
	memset(kfile,0,sizeof(struct __k_stat));
	char *_path=(char *)__path;
	ulong off_at=sep_offset(_path,"@");


	char *uname=str_b4offset(_path,off_at);
	ulong unlen=str_rwings(uname);

	char *ixes=str_a4offset(_path,off_at);
	ulong ixlen=str_rwings(ixes);

	memmove((&kfile->u_name),uname,unlen);
	memmove((&kfile->i_addr),ixes,ixlen);

	(kfile->exsp).ptrdx=__iptridx(__path);
	log_ptrdx(&((kfile->exsp).ptrdx));

	// (kfile->exsp).esptr=___exsptr(__path);
	// log_esptr((kfile->exsp).esptr);


	return 0;
};


/*******************************************************************/

void log_dpoint(dpoint_t *dst_point) {
	printf("dst point :: \n");
	printf("@%lu\n", dst_point->c_index);
	printf("name :%s\n",dst_point->c_name);
	printf("ref  :%s\n",dst_point->c_ref);
};

void log_kstat(k_stat *kfile) {
	printf("dcloud : K\n");
	printf("uname	= %s\n", kfile->u_name);
	printf("iaddr	= %s\n", kfile->i_addr);
};

void log_sstat(s_stat *sfile){
	printf("dcloud : ATP :: dist ::: shared\n");
	printf("path	= %s\n", sfile->s_path);
	printf("iploc	= %s\n", sfile->s_ipv);
	printf("port	= %s\n", __s_port);
	printf("addr	= %s\n", sfile->s_addr);
	printf("term	= %s\n", sfile->s_term==0?"PUBLIC":"PRIVATE");
};

void log_mstat(m_stat *mfile){
	printf("dcloud : ATP :: dist ::: mounted\n");
	printf("path	= %s\n", mfile->m_path);
	printf("nodenum	= %lu\n", mfile->m_inn);
	printf("size	= %lu\n",mfile->m_size);
	printf("mode	= %lu\n",mfile->m_mode);
	printf("blkio	= %lu\n",mfile->m_blksz);
};

void log_str(strld __){
	printf("string\n");
	printf("length=%d\n",__.len);
	printf("data:=%s\n",__.data);
};

void log_sepstr(spstr ss){
	printf("string=%s\nlength=%d\nseperator=%s\noffset=%d\n",ss.str,ss.str_length,ss.sep,ss.sep_offs);
};

void log_ptrdx(struct __ptrdx *ptrdx) {
	printf("dcloud : K :: ptrdx\n");
	printf("pidx :%lu\n",ptrdx->pidx);
	printf("tri  :%lu\n",ptrdx->tri);
};

void log_esptr(ulong *esptr) {
	printf("dcloud : K :: esptr\n");
	ulong c=0;
	do {
		printf(":%lu=%lu\n",c,esptr[c]);c+=1;
	}
	while(*esptr++);
};

void log_process_ids(ulong p_pid, ulong c_pid) {
   printf("process ids ::\n");
   printf("p.pid    =%lu\n",p_pid);
   printf("c.pid    =%lu\n",c_pid);
};

void log_process_schema(ulong p_pid, ulong c_pid) {
    printf("p_pid :: %lu",p_pid);
    printf("\nc_pid :: %lu",c_pid);
    printf("\nsuccess=%d\tnsucess=%d\n",CALL_SUCC(c_pid),CALL_NSUC(c_pid));
    printf("call next ? %lu\n",CALL_NEXT(c_pid));
};

void log_lbb_type(lbb_t lbbt) {
	switch(lbbt) {
	case lbb_entry:	printf("lbb {Entry}\n"); break;
	case lbb_ptr:		printf("lbb {Protocol}\n"); break;
	case lbb_intr: 	printf("lbb {Interpreter}\n"); break;
	case lbb_pyld:		printf("lbb {Payload}\n"); break;
	default: printf("{Unknown}\n"); break;
	};
};

/*******************************************************************/

ulong __get_long_digits(ulong num) {
	ulong cnum=((ulong)(num/10));
	ulong res=0;
	while(cnum!=0){
		res+=1;
		cnum=((ulong)(num/10));
	};
	return res+=1;
};
char *__get_cfname(char const *__fname, ulong __iter) {
	#ifdef DEBUG
		printf("cfname : %s :: %lu", __fname, __iter);
	#endif
	ulong __flen=str_rwings(__fname);
	char __[64];memset(&__,0,sizeof(__));
	sprintf(__,"%s:%lu",__fname,__iter);
	return strdup(__);
};

char const *__get_fcontents(char *__conts, ulong __size) {
	char __[__size];
	memset(&__,0,__size);
	sprintf(__,"{%s}",__conts);
	return (char const *)strdup(__);
};

void free_fields(fld **flds){
	ulong c=0;
	while(*flds++){
		free(flds[c]);
		c+=1;
	};
};
struct __conv_header {
	ulong chksize;
	char const *chkname;
	char const *chksum;
	char const *chkcont;
};
typedef struct __conv_header chk_st;

char const *__conv_fields(char const *__fn, ulong __fd, ulong __fld_count) {
	#ifdef DEBUG
		printf("fld ((conv)) ::\n");
		printf("fld name  : %s\n", __fn);
		printf("fld file  : %lu\n", __fd);
		printf("fld count : %lu\n", __fld_count);
	#endif
	char const *fld_name=__combine_str(__lbb_convdir, __fn);
	ulong c=0,_res=0,__offset=0;

	// create entry in lbb
	ulong lbb_dd=__lbb_file_n(fld_name);

	// reset the fld to be to 0
	fld field; memset(&field,0,size_fld);
	char *__buffer=(char *)&(field.fld_con.etc);
	__buffer[4095]='\0';


	chk_st cst;
	while(c<__fld_count){
		memset(&cst, 0, sizeof(chk_st));
		memset(__buffer,0,4024);
		#ifdef DEBUG
			printf("Conv Fields DEBUG :: %lu\n", c);
		#endif
		// read size
		int __tempres=pread(__fd,__buffer,4096,__offset);
		if(__tempres==-1) {
			#ifdef LOG_ERR
				printf("%s : convolution :: could not read file ::: %s\n", "@LBB", shd_path);
			#endif
			return NULL;
		}
		else if (__tempres==0) {
			#ifdef LOG_ERR
				printf("%s : convolution :: file is empty ::: %s\n", "@LBB", shd_path);
			#endif
			continue;
		}
		else {
		// get the total size of file contents
			cst.chksize=(ulong)__tempres;
			__offset+=cst.chksize;		
		};
		
		// get the charms file path
		cst.chkname=__get_cfname(__fn, c);
		// get checksum for entire file
		cst.chksum=(char *)hashof(1,field_content(field),field_length(field));
		#ifdef DEBUG
			printf("fld : file path      :: %s\n", cst.chkname);
			printf("fld : read size      :: %lu\n", cst.chksize);
			printf("fld : file checksum  :: %s\n", cst.chksum);
		#endif
		#ifdef OUTPUT
			OUT_ASCII(lbb_dd, cst.chksize);		
			OUT_ASCII(lbb_dd, cst.chkname);
			OUT_ASCII(lbb_dd, cst.chksum);
			OUT_ASCII(lbb_dd, field_content(field));
		#endif		
		// pack the contents as binary with s indicator
		c+=1;
	};
	
	close(lbb_dd);

	return strdup(fld_name);
};


ulong __flds_count(int c) {
	int __c=(int)c;
	ulong count=0;
	do {
		count+=1;
		__c-=4096;
	}while(__c>4096);
	return count;
}

char const *conv_fields(m_stat *m_st){
	ulong __fd=open(m_st->m_path,__lbb_share_flags), __size=(m_st->m_size), __count=__flds_count(__size);

	return __conv_fields(hashof(1,m_st,sizeof(m_stat)),__fd,__count);
};

/*******************************************************************/


enum __lbb_add_t {
	__command, 
	__filepath, 
	__function,
	__field,
	__addr
};
typedef enum __lbb_add_t lbb_at;

static void *__ne=(void *)'\0';
static const void *ne=(char const *)(void *)'\0';

#define __lbb_command_args (char const *, char const *)
#define __lbb_filepath_args (char const *, sterm)
#define __lbb_function_args (char const *, void *, void *)
#define __lbb_field_args (void const *)
#define __lbb_cc char const *
#define __lbb_vp void *

#define __lbb_call_args(...) __VA_ARGS__
#define lbb_add(x,...) __lbb_typd_args(x)

#define __lbb_call_generic(__) \
	_Generic((__),\
		ptr_st:"lbb command",\
		intr_st: "lbb interpreter",\
		payld_st: "lbb payload",\
		cis_st: "lbb field",\
	default:"lbb call")

#define __lbb_resp_generic(__) \
	_Generic((__),\
		ptr_st*:"command response",\
		intr_st*: "interpreter reply",\
		payld_st*: "payload retrieve",\
		cis_st*: "field return",\
	default:"unknown args")

#define __lbb_generic(__) \
	_Generic((__),\
		char[8]:(ptr_st *) &__,\
		char[64]:(intr_st *) &__,\
		char[512]:(payld_st *) &__,\
		char[4096]:(cis_st *) &__,\
		default:"unknown")

#define __lbb_typd(__) \
	_Generic((__),\
		ptr_st * : char[8],\
		intr_st * : char[64],\
		payld_st * : char[512],\
		cis_st * : char[4096],\
		default:"unknown")

int get_freader(m_stat *mst) {
	int _fd=open(mst->m_path,__lbb_lock_reader);
	if(_fd==-1){
		#ifdef LOG_ERR
			printf("cannot open reader for : %s\n", mst->m_path);
		#endif
		return -1;
	};
	ulong __fd=(ulong)_fd;
	lbb_shard.lbb_fd=__fd;
	#ifdef DEBUG
		printf("Reader : file opened :: %lu\n",shd_fd);
	#endif
	return 0;
};


char const *__lbb_command(char const *__cpath, char const *__args) {
	printf("lbb command @%s<%s>\n", __cpath, __args);
	int __res=-1;
	__res=get_mstat(__cpath, lbb_mstat);
	if(__res==-1) {
		#ifdef LOG_ERR
			printf("cannot obtain file @%s\n", __cpath);
		#endif
		return NULL;
	};
	return __args;
};


char const *__lbb_filepath(char const *__fpath, sterm __term) {
	#ifdef PROCESS
		printf("lbb filepath :%s+%c\n", __fpath, __term);
	#endif
	// check the file requested
	int __res=-1;
	__res=get_mstat(__fpath, lbb_mstat);
	if(__res==-1) {
		#ifdef LOG_ERR
			printf("cannot obtain file @%s\n", __fpath);
		#endif
		return NULL;
	};
	// log the stats of the file requested
	#ifdef DEBUG
		log_mstat(lbb_mstat);
	#endif
	// get a reader for the file
	// if stat is obtained but reader
	// is not, most likely already added
	// or no permissions
	__res=get_freader(lbb_mstat);
	if(__res==-1) {
		#ifdef LOG_ERR
			printf("%s : filepath :: cannot open reader ::: %s \n", "@LBB", __fpath);
		#endif
		return NULL;
	};
	#ifdef PROCESS
		printf("lbb@%lu<%lu>\n", shd_fd, shd_sze);
	#endif
	ulong count=__flds_count(shd_sze);
	char const *convres=__conv_fields(shd_key,shd_fd,count);

	lbb_close();
	if(convres==NULL) {
		#ifdef LOG_ERR
			printf("could not do a convolution for path : %s\n", __fpath);
		#endif
		return shd_path;
	};
	#ifdef OUTPUT
		printf("@lbb%s\n filepath : %s\n", shd_key, __fpath);
	#endif
	return shd_key;
};

void const *__lbb_function(char const *__name, void const *__intype, void const *__castout) {

	printf("lbb function ::%s(%s)=%s\n", __name, __lbb_call_generic(__intype), __lbb_resp_generic(__castout));

	return __ne;
};

void __free_ptr(void const *__) {
	free((void *)__);
}

void const *__lbb_field(char const *__keyname, void const *__content) {

	printf("lbb field <%s> ::: %p \n", __keyname, __content);

	__free_ptr(__content);
	return __ne;
};

void const *__lbb_address(void *__) {

	printf("lbb address @%p", __);

	return __ne;
};

void const *__lbb_type_args(lbb_at __atype) {
	switch(__atype){

	case __command: return (char const *(*)(char const *, char const *))&__lbb_command;

	case __filepath: return (char const *(*)(char const *, sterm))&__lbb_filepath;

	case __function: return (void *(*)(char const *, void *, void *))&__lbb_function;

	case __field: return (void *(*)(char const *))&__lbb_field;

	default: return (void *(*)(__lbb_vp))&__lbb_address;

	};
	return __ne;
};















#endif