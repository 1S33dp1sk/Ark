#include "lenk.h"

// various bits for floating point types--
// varies for different architectures
#define float32_t float
#define float64_t double



int pack_unpack_test() {
    unsigned char buf[1024];
    memset(&buf , 0 , sizeof( buf ));
    unsigned long long int number;
    uchar magic;
    int16_t monkeycount;
    int32_t altitude;
    float32_t absurdityfactor;
    char *s = "Great unmitigated Zot! You've found the Runestaff!";
    char s2[96];
    int16_t packetsize, ps2;

    packetsize = pack(buf, "Q", 1212333399999 );

    printf("packet is %ld bytes\n", packetsize);

    unpack(buf, "Q", &number);

    printf("unpacked :: '%llu'\n " , number);

    return 0;
}

int main( int argc , char const **argv ) {
    if ( argc == 1 ) {
        return pack_unpack_test();
    }
    else if ( argc == 4 ) {
        #ifdef DEBUG
            printf("lenk :: \n")
            printf( "e/d :: %c\n", argv[1][0] );
            printf( "type :: %s\n", argv[2] );
            printf( "value :: %s\n", argv[3] );
        #endif
        if ( argv[1][0] == 'e' ) {
            uchar buf[512];
            memset( &buf , 0 , sizeof(buf));
            ulong packet_size = 0;
            packet_size = pack(buf,argv[2],*(&argv[3]));
            printf( "packet size :: %ld\n" , packet_size );
            char s_decoded[100];
            unpack(buf,argv[2],&s_decoded);
            printf("decoded : `%s` \n", s_decoded);
        }
    }
    else {
        printf("usage ::\tlenk (tests encoding & decoding)\n\tlenk e/d type value\n");
    }




    return 0;
}
