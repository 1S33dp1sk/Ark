#include "aether.h"

/**
 * aether is a two choice and a next; system k = 3.
 * The current default value, defines the k which is essentially the base of the sys.
***
 * choice 1 :
 *      K
 * choice 2 :
 *      les
 * current : 
 *      .lbb
 * 
 * There's no need for security configurations as the system is isolated based on the 
 * context created by the serve then the request then the response.
 * with it's own user, sockets, listeners, repliers, etc... . 
 * 
 * 
 * and finally, the lbb keeps track of the default and changes. a differencing library essentially,
 * because neither 0xather nor the atherpoints care about state changes, the implementation is 100% dynamic.
 * 0xather is the name of the full interconnectivity of atherpoints
 * now the `0x`(ather) is essentially how we can differenciate between the different cores, so the basic
 * is at ( @her )  == home
 * is at ( ip.ather ) == local
 * is at ( ip6:ather ) == global
 * is at ( 0xather ) == universal
 * 
 * universal must be blockchain-based.
 * 
 * any type of atherfile a.k.a socket/server/les can relay lbb requests to the local socket.
 * the local socket decides on /K | .lbb\
 * 
 * the request is simple :
 *
 * key @ atherpoint {
 *      !#entry
 * }
 * 
 * the response is simplier :
 * 
 * response @ hash {
 *      LOG
 * }
 * 
 * 
 * entries can contain any executable, script, function, command, etc... .
 * an entry can be 
 * 
 *       #{ 
 *          !#
 *          #! 
 *       }
 * 
 * the aether is a system-wide user than can only execute in it's own directory. 
 * 
 * Nonetheless, the core technology here is adaptive, so execution is based on the wrapper which
 * is the ather in the amount of bit processing between the different atherpoints. @atherpoint is fully defined if the ::
 *      path/to/@||path\to\@ is defined
 *      192.168.*.*|10.0.1.0 is defined 
 *      6f:::*||6f0:000:201:3fa:102:a21 is defined
 *      eth201||btcd12a is defined
 *  
 * 
 * access differes based on defined iota's in the .lbb 
 * basically when accessing the .lbb, the main call is ( K , res )
 * res -> responsible for providing that context. only way for that to happen, is if K is viable.
 */


int main(int argc, char *argv[]) {
    int __ = argc > 1 ? super_fast_hash( argv[1] , strlen( argv[1] ) ) : 0;

    switch( __ ) {
        case 0:
            break;
        case 0x9eefc5c9:
            mor( argc , argv );
            break;
        case 0x350647ed:
            les( argc , argv );
            break;
        default:
            break;
    }

    // les( argc , argv );
    // mor( argc , argv );
    return 0;
}




