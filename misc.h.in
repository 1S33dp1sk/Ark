/*
    -----------------------------------------------------------------------------------------------------
    |@ ::                                                                                               |
    | the `at` is a common character defined in UTF-8 under the sequence of 64. it is utilized by ather |
    | as the main indicator that there's ather or not.                                                  |
    -----------------------------------------------------------------------------------------------------
*/
#ifdef ATT_VERSION
    #include <unistd.h>
    #include <stdio.h>
    #include <stdlib.h>
    #include <sys/stat.h>
    #include <sys/socket.h>
    #include <stdint.h>
    #include <sys/types.h>
    #include <arpa/inet.h>
    #include <netdb.h>
    #include <string.h>
    #include <fcntl.h>
    #include <dirent.h>
    #include <ctype.h>
    #include <ifaddrs.h>
    #include <stdarg.h>
    
    #include "lbb_types.h"



// binary interface 
// invoke , ABI , pack , etx..
// adaptive based on the system 
#define i16( __ , _ ) __I( __ , _ , 0 ) // 16-bit comms
#define i32( __ , _ ) __I( __ , _ , 2 ) // 32-bit comms
#define i64( __ , _ ) __I( __ , _ , 6 ) // 64-bit comms
// binary mirror
// reply , ABM , unpack , etx..
#define r16( __ , _ ) __R( __ , _ , 0 ) // 16-bit comms
#define r32( __ , _ ) __R( __ , _ , 2 ) // 32-bit comms
#define r64( __ , _ ) __R( __ , _ , 6 ) // 64-bit comms


char *__path_linux( char *__path , char *__filename ) {
    int path_len = strlen( __path ) - 1 , fname_len = strlen( __filename ) - 1;
    if ( __path[path_len] != '/' && __filename[0] != '/' ) {
        strncat( __path , "/\0" , 2 );
    }
    return ( path_len + fname_len ) < max_path ? strcat( __path , __filename ) : NULL;
}

void *get_in_addr(struct sockaddr *_s_addr ) {
    if ( _s_addr -> sa_family == AF_INET ) {
        return &( ( ( struct sockaddr_in * ) _s_addr ) -> sin_addr );
    }
    return &( ( ( struct sockaddr_in6 * ) _s_addr ) -> sin6_addr );    
}

void get_in_dir( char *base_path , a_info *path_entry ) {
    DIR *_d;
    struct dirent *__dir;
    if ( _d = opendir( base_path ) ) {
        while ( ( __dir = readdir( _d ) ) != NULL ) {
        	// do stuff with dir
        }
        closedir( _d );
    }
}

void exec( struct __entry *__entry__ ) {
    if ( strlen( __entry__ -> __ctx ) > 2 ) {
        __entry__ -> __depth += 1;
        __entry__ -> __res = system( __entry__ -> __ctx );
    }
}
 
void unpack__( uchar *__ , char *__fmt , struct __protocol *p ) {
    unsigned int __len = 0;
    for( ; *__fmt != '\0'; __fmt++ ){
        switch ( *__fmt ) {
            case 'a':
                p -> _len = r16( __ , 0 );
                __ += 2;
                break;
            case 'A':
                __len = r16( __ , 0 );
                __ += 2;
                memcpy( p -> _name , __ , __len );
                (p->_name)[__len] = '\0';
                __ += __len;
                break;
            case 'e':
                p -> _size = r16( __ , 0 );
                __ += 2;
                break;
            case 'd':
                p -> _diff = *__++;
                break;
            case 'N':
                __len = r16( __ , 0 );
                __ += 2;
                memcpy( p -> _type , __ , __len );
                (p -> _type)[__len] = '\0';
                __ += __len;
                break;
            case 'M':
                p -> _selector = r64( __ , 0 );
                __ += 8;
                break;
            case 'E':
                __len = r16( __ , 0 );
                __ += 2;
                memcpy( p -> _bin , __ , __len );
                (p -> _bin)[__len] = '\0';
                __ += __len;
                break;
        }       
        __len = 0;
    }
}

ulong __pack( uchar *__ , char *__fmt , struct __protocol *p ) {
    ulong __size = 0; 
    ulong __len = 0; 
    for( ; *__fmt != '\0'; __fmt++ ){
        switch( *__fmt ) {
            // p -> _len
            case 'a':  
                __size += 2;
                i16( __ , p -> _len );
                __ += 2;
                break;
            // p -> _name
            case 'A':
                __len = strlen( p -> _name );
                if ( __len != p -> _len ) {
                    perror( "Protocol issue : 1 -> name length does not match str length" );
                    return 0;
                }
                __size += __len + 2;
                i16( __ , __len );
                __ += 2;
                memcpy( __ , p -> _name , __len );
                __ += __len;
                break;
            // p -> _size 
            case 'e':
                __size += 2;
                i16( __ , p -> _size );
                __ += 2;
                break;
            // p -> _diff
            case 'd':
                __size += 1;
                *__++ = p -> _diff;
                break;
            // p -> _type
            case 'N':
                __len = strlen( p -> _type );
                __size += __len + 2;
                i16( __ , __len );
                __ += 2;
                memcpy( __ , p -> _type , __len );
                __ += __len;
                break;
            // p -> _selector
            case 'M':
                __size += 8;
                i64( __ , p -> _selector );
                __ += 8;
                break;
            // p -> _bin
            case 'E':
                __len = strlen( p -> _bin );
                __size += __len + 2;
                i16( __ , __len );
                __ += 2;
                memcpy( __ , p -> _bin , __len );
                __ += __len;
                break;
        }
        __len = 0;
    }
    return __size;
}

ulong find_ip_address(uchar *h_name, uchar *h_ip) {
      struct hostent *host_name;     
      struct in_addr **ipaddress;     
      int count;     
      if ( ( host_name = gethostbyname( h_name ) ) == NULL ) { 
            printf("\nIP Address Not Found\n");         
            return 1;
      }   
      else {  
            ipaddress = (struct in_addr **) host_name->h_addr_list;
            for(count = 0; ipaddress[count] != NULL; count++) {   
                  strcpy(h_ip, inet_ntoa(*ipaddress[count]));
                  return 0;
            }
      }
      return 1;
} 

ulong _check_entry_head( char *entry_h ) {
    const int ascii_entry[7] = { 69, 78, 84, 82, 89, 123, 32 };
    for ( int _i=0; _i<6; _i++ ) {
        if ( entry_h[_i] != ascii_entry[_i] ) {
            return 0;
        }
    }
    return 1;
}

ulong _make_entry_ctx( char *_entry , struct __entry *__entry__ ) {
    ulong _iterlen = strlen( _entry );
    ulong _idx = 0;
    for( ; _idx < _iterlen ; _idx++ ) {
        if ( _entry[_idx] == '#' ) {
            break;
        }
    }
    uchar *__ref = &(_entry[_idx+1]);
    strncpy( __entry__ -> __ctx , __ref , _iterlen - _idx );
    return 0;
}

ulong connect_path( struct __path *path , struct __connc *connc ) {
    DIR *d;
    struct dirent *dir;
    connc -> __dirs = malloc( MAX_STR * sizeof( char ) * 2 );
    connc -> filedata = malloc( sizeof( FileData * ) * 100 );
    char *temp = malloc( MAX_STR * sizeof( char ) );
    temp = strcpy( temp , path -> __main );
    if ( d = opendir( temp ) ) {
        // log__header( &(path -> __node)[1] );
        while ( ( dir = readdir( d ) ) != NULL ) {
           _check_base_entry( temp , dir , connc );
           connc -> __total += 1;
        }
        closedir( d );
    }
    free( temp );
}

ulong _check_dir_ft( char *base_path , struct dirent *dir_entry , struct __connc *connc ) {
    char *__name = malloc( MAX_STR * sizeof( char ) );
    strcpy( __name , dir_entry -> d_name );
    // __name = dir_entry -> d_name;
    if ( __name[0] == '.' ) {
        // check if:`d_type`::dir_entry -> d_reclen*
        if ( dir_entry -> d_type == DT_DIR || dir_entry -> d_reclen == 24 ) {
            // printf( "@dir( %s/%s )\n" , base_path , __name );
            return 0;
        }
        else {
            if ( strcmp( __name , ".lbb" ) == 0 ) {
                // printf( "%s found.\n" , ATHER_FILE );
                return 0;
            }
            return 0;
        }
        return 0;
    }
    else {
        switch ( dir_entry -> d_type ) {
            case DT_REG:
                ( connc -> filedata )[connc->num__files] = malloc( sizeof( FileData ) );
                strcpy( (connc->filedata)[connc->num__files] -> __name , __name );
                connc -> num__files += 1;
                // printf( "@file( %s/%s )\n" , base_path , __name );
                return 0;
            case DT_DIR:
                (connc -> __dirs)[connc->num__dirs] = malloc( MAX_STR * sizeof( char ) );
                strcpy( (connc -> __dirs)[connc->num__dirs] , __name );
                // printf( "@dir( %s/%s )\n" , base_path , *(connc -> __dirs) );
                connc -> num__dirs += 1;
                return 0;
            default:
                printf( "unknown :: %d : %s\n" , __name , dir_entry -> d_type );
                return 1;
        }
        return 0;        
    }
}

ulong _make_tempfile( char *file_path , struct __protocol *p ) {
    ulong __dfd;
    uchar __buf[1024];
    __dfd = open( file_path , O_RDWR|O_CREAT , S_IRWXU );
    ulong _size = __pack( __buf , "E\0" , &p );
    write( __dfd , __buf , _size );
    close( __dfd );
    return 0;
}

ulong _get_tempfile( char *file_path , struct __protocol *p ) {
    ulong __dfd;
    uchar __buf[1024];
    __dfd = open( file_path , O_RDWR );
    read(__dfd,__buf,1023);
    // printf("reading..\n");
    unpack__( __buf , "E\n" , &p );
    return 0;
}

ulong _pathify( struct __fieldlock *_ ) {
    char *temp , *_ptr = ( _ -> path -> __main );
    int _length = strlen( _ptr );
    int __len = 0, __FLAG = 0;
    while ( _length > 0 ) {
        temp = ( char * )( &_ptr[_length] );
        if ( strstr( temp , _ -> _path -> __home ) != NULL && __FLAG == 0 ) {
            __len = strlen( temp );
            // _lestyle( _ -> _type , temp , _ -> _path -> __name );
            __FLAG = 1;
        }
        if ( __FLAG == 1 ) {
            strcpy( _ -> _path -> __wd , (&_ptr[strlen( _ptr )-_length]) );
            __FLAG = 2;
        }
        if ( strstr( temp , "@/" ) == NULL && __FLAG == 2 ){
            break;
        }
        _length--;
    }
    strncat( _ -> _path -> __pub , _ptr , strlen( _ptr ) - strlen( temp ) );
    temp = _ -> _path -> __pub;
    temp[strlen( temp )] = '@';
    if ( __dirdata( temp ) != 0 ) {
        memset( _ -> _path -> __pub, 0, strlen( temp ) );
    }
    return 0;
}

uchar *entry( char *_entry , struct __entry *__entry__ ) {
    char *_e__name = malloc( MAX_STR * sizeof( char ) );
    _e__name = strtok_r( _entry , ENTRY__END , &_entry );
    int __;
    if ( ( __ = __check__entry( _e__name ) ) == 10 ) {
        _entry = strtok( NULL , ENTRY__END );
        _make_entry_ctx( _entry , __entry__ );
    }
    return _entry;
}



//  linux   -   #man getifaddrs
//              #man freeifaddrs
// GNU LICENSE
// struct ifaddrs {
//    struct ifaddrs  *ifa_next;    /* Next item in list */
//    char            *ifa_name;    /* Name of interface */
//    unsigned int     ifa_flags;   /* Flags from SIOCGIFFLAGS */
//    struct sockaddr *ifa_addr;    /* Address of interface */
//    struct sockaddr *ifa_netmask; /* Netmask of interface */
//    union {
//        struct sockaddr *ifu_broadaddr;
//                         /* Broadcast address of interface */
//        struct sockaddr *ifu_dstaddr;
//                         /* Point-to-point destination address */
//    } ifa_ifu;
// #define              ifa_broadaddr ifa_ifu.ifu_broadaddr
// #define              ifa_dstaddr   ifa_ifu.ifu_dstaddr
//    void            *ifa_data;    /* Address-specific data */
// };


// char cur_ip[INET6_ADDRSTRLEN] = {0};
// struct ifaddrs *_lcon, *_lconns;
// int __ = getifaddrs( &_lconns );
// for ( _lcon = _lconns; _lcon != NULL ; _lcon = _lcon -> ifa_next ) {
//  __ip( cur_ip , _lcon -> ifa_netmask );
//  log_ip_debug( cur_ip );
//  // log_ifaddr_debug( _lcon );
// }
// freeifaddrs( _lconns );




// improv : add GNU|OS dependent MAX LIMITS
    // **/
    // #if ( !defined( aliaslist ) && !defined( lvl_st )  )
    //  #define lvl_st struct level_aliases
    //  struct level_aliases {
    //      unsigned lnum;
    //      char *lname;
    //      char *lnetname;
    //  } __aliaslist[] = { 
    //      {   0 , "mac"       , "localhost"   },
    //      {   1 , "point"     , "athernet"    },
    //      {   2 , "global"    , "internet"    },
    //      {   3 , "blockchain", "network" }
    //  };
    // #endif
    // #define aliaslist __aliaslist

// #define __kurl__( __ ) \
    //      do {\
    //          __ = al__ init_kurl;\
    //          p_ref = &__;\
    //          return __al__( __ );\
    //      } while ( 0 )
    //  #define al int 
    //  #define al__ ( int * )
    //  #define __al__( __ ) (( al2 )( __ ))
    //  #define al2 long
    //  static probe p_ref;
    //  #ifndef builder
    //      #define builder 
    //      extern al2 builder __kurl__( p_ref ) {
    //          __ = al__ init_kurl;
    //          p_ref = &__;
    //          return __al__( __ ) ;
    //      }
    //  #endif
    //  #define nin ( ( long ) ( -1&0xf000000000000000 ) )
    //  #define pin ( ( long ) ( +1|0x0111111111111111 ) )

// #ifndef __kurl_probe__
    //  #define __kurl_probe__ upgrade_probe
    //  #define url_r( u_ ) u_ > nin ? 1 : 0
    //  #define url_l( u_ ) u_ < pin ? 1 : 0
    //  #define url__( __ ) __ == nin ? -1 : __ == pin ? 1 : 0
    //  #define levelof( __ ) sizeof( __ ) == sizeof( int ) ? \
    //      0 : sizeof( __ ) == sizeof( long ) ? \
    //      1 : sizeof( __ ) == sizeof( long long ) ? \
    //      2 : sizeof( __ ) > sizeof( long long ) * 2 ? \
    //      3 : 0
    //  #define decode_probe( p__ ) p__>>1
    //  #define upgrade_probe( p__ ) p__ == 0x0001 ? \
    //          p__|= 0x0010 : p__ == 0x0011 ? \
    //          p__|= 0x0100 : p__ == 0x0111 ? \
    //          p__|= 0x1000 : p__ == 0x1111 ? \
    //          p__&= 0x0000 : 0
    // #endif







#endif

