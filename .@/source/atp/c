/// ATP \\\
@ protocol


#ifndef __ATP__H
#include "atp.h"
#endif

#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <string.h>
#include <sys/socket.h>
#include <sys/types.h>
#include <arpa/inet.h>
#include <netinet/in.h>
#include <netdb.h>
#include <sys/wait.h>
#include <errno.h>


char const *hashof(unsigned level, void const *to_hash, ulong hash_size);

// #define DEBUG 1

enum __atypes_ stype_to_atype(enum __stypes __stype) {
    switch(__stype) {
        case __sAF_INET: return at4;
        case __sAF_INET6: return at6;
        default: return at4;
    }
};

enum __stypes a2s_type(enum __atypes_ _atype) {
    switch(_atype) {
        case at4: return __sAF_INET;
        case at6: return __sAF_INET6;
        default: return __sAF_INET;
    };
};

struct __socket_address {
    enum __atypes_ _atype;
    void *_sokaddr;
    char _sockaddr[128];
    char ascii_addr[INET6_ADDRSTRLEN];
};

typedef struct __socket_address aip_saddr;

void _socket_free_fd(struct __sok_t *sok_t) {
    close(sok_t->aip_sockfd);
};

void _socket_address_free(struct __socket_address *aip_sa){
    free(aip_sa->_sokaddr);
};

enum __atypes_ get_atype(struct __socket_address *aip_sa) {
    return aip_sa->_atype;
};

void *get_sokaddr(struct __socket_address *aip_sa) {
    return aip_sa->_sokaddr;
};

char *get_sockaddr(struct __socket_address *aip_sa) {
    return (char *)&(aip_sa->_sockaddr);
};

void *__sok_addr(struct sockaddr *sa) {
    if (sa->sa_family == AF_INET) {
        return &(((struct sockaddr_in*)sa)->sin_addr);
    }
    else {
        return &(((struct sockaddr_in6*)sa)->sin6_addr);
    };
    return NULL;
};

// get sockaddr, IPv4 or IPv6:
struct __socket_address __sock_addr(struct sockaddr *sa) {
    struct __socket_address __sa;
    memset(&__sa,0,sizeof(struct __socket_address));
    if (sa->sa_family == AF_INET) {
        __sa._atype=at4;
        __sa._sokaddr=&(((struct sockaddr_in*)sa)->sin_addr);
    }
    else {
        __sa._atype=at6;
        __sa._sokaddr=&(((struct sockaddr_in6*)sa)->sin6_addr);
    };
    char s[INET6_ADDRSTRLEN];
    ulong __s_size=sizeof(__sa.ascii_addr);
    memset(__sa.ascii_addr,0,__s_size);
    memset(&s,0,sizeof(s));
    char const *sockname=inet_ntop(a2s_type(__sa._atype), __sa._sokaddr, s, sizeof(s));
    memmove(__sa.ascii_addr, sockname, __s_size);
    #ifdef DEBUG
        printf("socket @%s\n",sockname);
    #endif
    return __sa;
};

struct sockaddr *sock_aip_to_sa(aipsock *sock){
    struct sockaddr_storage *saddrst=((struct sockaddr_storage *)(&(sock->aip_socket)));
    return (struct sockaddr *)saddrst;
};

void log_socket(aipsock *sock) {
    struct __socket_address info=__sock_addr(sock_aip_to_sa(sock));
    printf("socket @%s\n",info.ascii_addr);
};

struct addrinfo __hints() {
	struct addrinfo info;
	info.ai_socktype=SOCK_STREAM;
	info.ai_family=PF_UNSPEC;
	return info;
};

char *uname(const char *__filename) {

	return (char *)hashof(2,__filename,strlen(__filename));
};

struct __sok_t __arcsocket() {
    aipsock __sok;
    memset(&__sok,0,sizeof(struct __sok_t));

    struct addrinfo hints=__hints();
    hints.ai_flags=AI_PASSIVE;
    struct addrinfo *srvinfo, *aip;
    struct sockaddr_storage ss_addr;
    int __sfd=-1;
    socklen_t slen;
    char s_addr[INET6_ADDRSTRLEN];
    memset(&s_addr,0,sizeof(s_addr));

    if (getaddrinfo(NULL,ATP_PORT,&hints,&srvinfo)){
        #ifdef DEBUG
            printf("getaddrinfo error");
        #endif
        memset(&ss_addr,0,sizeof(struct sockaddr_storage));
        return __sok;
    };

    int __yes=1;

    for(aip=srvinfo;aip!=NULL;aip=aip->ai_next){
        if((__sfd=socket(aip->ai_family,aip->ai_socktype,aip->ai_protocol))==-1){
            #ifdef DEBUG
                printf("server :: socket\n");
            #endif
            continue;
        }
        if(setsockopt(__sfd,SOL_SOCKET,SO_REUSEADDR,&__yes,sizeof(unsigned))==-1){
            #ifdef DEBUG
                printf("setsockopt\n");
            #endif
            exit(1);
        }
        if(bind(__sfd,aip->ai_addr,aip->ai_addrlen)==-1){
            close(__sfd);
            #ifdef DEBUG
                perror("server: bind\n");
            #endif
            continue;
        }
        #ifdef DEBUG
            printf("aip->next");
        #endif
        break;  
    }


    freeaddrinfo(srvinfo);

    __sok.aip_sockfd=__sfd;
    __sok.aip_socklen=(ulong)(aip->ai_addrlen);
    struct sockaddr_storage *sasp=(struct sockaddr_storage*)aip->ai_addr;
    memmove((__sok.aip_socket), sasp, sizeof(struct sockaddr_storage));

    return __sok;
};

#define socket_fd(x) (ulong)(x.aip_sockfd)
#define sock_fd(x) (ulong)(x->aip_sockfd)
#define socket_len(x) (ulong)(x.aip_socklen)
#define sock_len(x) (ulong)(x->aip_socklen)
#define socket_staddr(x) (struct sockaddr *) sock_aip_to_sa(&x)
#define DEBUG 1

int __aip_listen(ulong aipsfd){
    int res=listen(aipsfd,ATP_BACKLOG)==-1?1:0;
    if(res==-1){
        printf("err number:\n");
        printf("%d\n",errno);
        return 1;   
    }
    return 0;
};

void __aip_send(aipsock *sock, char *msg_to_send){
    ulong msglen=strlen(msg_to_send);
    if(send(sock_fd(sock),msg_to_send,msglen,0)==-1){
        #ifdef DEBUG
            printf("send : failed :: payload { %s }\n", msg_to_send);
        #endif
    }
}


int __incheck(char c){   
    if( (c>=0x30)&&(c<=0x39)){
        #ifdef DDEBUG
            printf("char %c has a value of %d\n",c,c);  
        #endif
        return 1;
    };
    return 0;
};

ulong __tonum(char const *var){
    ulong d=1,__c=0,res=0,__len=strlen(var);
    int c;
    if(var[__len]=='\0'){
        while(__incheck(var[__c])){
            d*=10;
            __c+=1;
        };
        __c=0;
        if(d>=10){d/=10;}
        #ifdef DDEBUG
            printf("digits count :: %lu\n",d);
        #endif
        while(__incheck(var[__c])){
            res+=(d*(var[__c]-0x30));
            __c+=1;d/=10;
        }
        #ifdef DDEBUG
            printf("result is :: %lu\n", res);
        #endif
    };
    return res;
};


ulong tonum(int i){
    ulong res=0;
    if(i>0){
        res+=i;
        return res;
    };
    return 0;
}

void sock_errs(){
    printf("value of EBADF = %d\n", EBADF);
    printf("value of ENOTSOCK = %d\n", ENOTSOCK);
};



void __ellrun(ulong __fd, ulong __len, struct sockaddr *__addr) {

    aipsock temp_sok;
    memset(&temp_sok,0,sizeof(aipsock));

    while(1) {
        socklen_t *temp_sockelen=((socklen_t *)&(temp_sok.aip_socklen));
        ulong *temp_sockefd=((ulong *)&(temp_sok.aip_sockfd));
        struct sockaddr *temp_sockeaddr=((struct sockaddr *)&(temp_sok.aip_socket));
        *temp_sockelen=sizeof(temp_sockeaddr);
        int __tempfd=accept(__fd, temp_sockeaddr, temp_sockelen);
        if(__tempfd==-1) {
            #ifdef DEBUG
                printf("error : accept :: ");
                printf("err number ::: ");
                printf("%d\n",errno);
                break;
            #endif
            continue;
        };
        temp_sok.aip_sockfd=tonum(__tempfd);
        #ifdef DEBUG
            log_socket(&temp_sok);
        #endif
        if(!fork()){
            close(__fd);
            __aip_send(&temp_sok, "ell shell ::\n");
            _socket_free_fd(&temp_sok);
            exit(0);
        }
        _socket_free_fd(&temp_sok);
    };
};


void *__arcell(void *c_stp) {
    struct __sok_t __socket =__arcsocket();
    struct __socket_address saddr_st=__sock_addr(sock_aip_to_sa(&__socket));

    ulong socket_fd=socket_fd(__socket);
    ulong socket_len=socket_len(__socket);
    struct sockaddr *socket_addr=socket_staddr(__socket);


    #ifdef DEBUG
        printf("starting ell, <%p>\n", c_stp);
        printf("fd=%lu",socket_fd);
        log_socket(&__socket);
    #endif

    if(__aip_listen(socket_fd)) {
        #ifdef DEBUG
            printf("error : listen\n");
            printf("err number:\n");
            printf("%d\n",errno);
        #endif
        _exit(1);
    };


    __ellrun(socket_fd,socket_len,socket_addr);

    return c_stp;
};


int lbb_run() {
    printf("d-cloud : atp {mor}\n");

    int sockfd, numbytes;  
    char buf[ATP_BUFFER_SIZE];
    struct addrinfo hints=__hints();
    struct addrinfo *servinfo, *p;
    int rv;
    char s[INET6_ADDRSTRLEN];


    if ((rv = getaddrinfo(NULL, ATP_PORT, &hints, &servinfo)) != 0) {
        #ifdef DEBUG
            fprintf(stderr, "getaddrinfo: %s\n", gai_strerror(rv));
        #endif
        return 1;
    }

    // loop through all the results and connect to the first we can
    for(p = servinfo; p != NULL; p = p->ai_next) {
        if ((sockfd = socket(p->ai_family, p->ai_socktype,
                p->ai_protocol)) == -1) {
            #ifdef DEBUG
                perror("client: socket");
            #endif
            continue;
        }

        if (connect(sockfd, p->ai_addr, p->ai_addrlen) == -1) {
            close(sockfd);
            #ifdef DEBUG
                perror("client: connect");
            #endif
            continue;
        }

        break;
    }

    if (p == NULL) {
        #ifdef DEBUG
            fprintf(stderr, "client: failed to connect\n");
        #endif
        return 2;
    }

    inet_ntop(p->ai_family, __sok_addr((struct sockaddr *)p->ai_addr), s, sizeof s);
    #ifdef DEBUG
        printf("client: connecting to %s\n", s);
    #endif
    freeaddrinfo(servinfo); // all done with this structure

    if ((numbytes = recv(sockfd, buf, ATP_BUFFER_SIZE-1, 0)) == -1) {
        #ifdef DEBUG
            perror("recv");
        #endif
        exit(1);
    }

    buf[numbytes] = '\0';

    #ifdef DEBUG
        printf("client: received '%s'\n",buf);
    #endif
    close(sockfd);

    return 0;
}


int les(void) {
    printf("d-cloud : atp {les}\n");
    int __fd, temp_fd, __yes=1, __rv;
    struct addrinfo hints=__hints(); 
    struct addrinfo *__servinfo, *temp;
    struct sockaddr_storage __caddr;

    socklen_t __sin_size;
    char __saddr[INET6_ADDRSTRLEN];

    if ((__rv=getaddrinfo(NULL,ATP_PORT,&hints,&__servinfo))!=0){
        #ifdef DEBUG
            fprintf(stderr, "getaddrinfo: %s\n", gai_strerror(__rv));
        #endif
        return 1;
    }

    for(temp=__servinfo;temp!=NULL;temp=temp->ai_next){
        if((__fd=socket(temp->ai_family,temp->ai_socktype,temp->ai_protocol))==-1){
            #ifdef DEBUG
                perror("server :: socket\n");
            #endif
            continue;
        }
        if(setsockopt(__fd,SOL_SOCKET,SO_REUSEADDR,&__yes,sizeof(unsigned))==-1){
            #ifdef DEBUG
                perror("setsockopt\n");
            #endif
            exit(1);
        }
        if(bind(__fd,temp->ai_addr,temp->ai_addrlen)==-1){
            close(__fd);
            #ifdef DEBUG
                perror("server: bind\n");
            #endif
            continue;
        }
        break;
    }

    freeaddrinfo(__servinfo);

    if(temp==NULL){
        #ifdef DEBUG
            fprintf(stderr,"server : failed to bind\n");
        #endif
        exit(1);
    }
    if(listen(__fd,ATP_BACKLOG)==-1){
        #ifdef DEBUG
            perror("listen\n");
        #endif
        exit(1);
    }

    while(1){
        __sin_size=sizeof(__caddr);
        temp_fd=accept(__fd,(struct sockaddr*)&__caddr,&__sin_size);
        if(temp_fd==-1){
            #ifdef DEBUG
                perror("accept\n");
            #endif
            continue;
        }
        inet_ntop(__caddr.ss_family,__sok_addr((struct sockaddr*)&__caddr), __saddr, sizeof(__saddr));
        #if LBB_LOG >= 2
            printf("server : got connection from %s\n",__saddr);
        #endif
        if(!fork()){
            close(__fd);

            char *msg_to_send="Hello World\0";
            ulong msglen=strlen(msg_to_send);

            if(send(temp_fd,msg_to_send,msglen,0)==-1){
                #ifdef DEBUG
                    perror("send\n");
                #endif
            }
            close(temp_fd);
            exit(0);
        }
        close(temp_fd);
    }
    return 0;
};

int mor(void) {
    printf("d-cloud : atp {mor}\n");

    int sockfd, numbytes;  
    char buf[ATP_BUFFER_SIZE];
    struct addrinfo hints=__hints();
    struct addrinfo *servinfo, *p;
    int rv;
    char s[INET6_ADDRSTRLEN];


    if ((rv = getaddrinfo(NULL, ATP_PORT, &hints, &servinfo)) != 0) {
        #ifdef DEBUG
            printf("getaddrinfo: %s\n", gai_strerror(rv));
        #endif
        return 1;
    }

    // loop through all the results and connect to the first we can
    for(p = servinfo; p != NULL; p = p->ai_next) {
        if ((sockfd = socket(p->ai_family, p->ai_socktype,
                p->ai_protocol)) == -1) {
            #ifdef DEBUG
                printf("client: socket");
            #endif
            continue;
        }

        if (connect(sockfd, p->ai_addr, p->ai_addrlen) == -1) {
            close(sockfd);
            #ifdef DEBUG
                printf("client: connect");
            #endif
            continue;
        }

        break;
    }

    if (p == NULL) {
        #ifdef DEBUG
            printf("client: failed to connect\n");
        #endif
        return 2;
    }

    inet_ntop(p->ai_family, __sok_addr((struct sockaddr *)p->ai_addr), s, sizeof s);
    #if DEBUG
        printf("client: connecting to %s\n", s);
    #endif
    freeaddrinfo(servinfo); // all done with this structure

    if ((numbytes = recv(sockfd, buf, ATP_BUFFER_SIZE-1, 0)) == -1) {
        #ifdef DEBUG
            printf("recv");
        #endif
        exit(1);
    }

    buf[numbytes] = '\0';

    #if DEBUG
        printf("client: received '%s'\n",buf);
    #endif
    close(sockfd);

    return 0;
};

int spec_set_type(spec *sp, gfmt g) {
    sp->g_ev=g;
    sp->g_delim=DELIM(g);
    return 0;
};

char const *__gdelim(__gev __gtype) {
    char __delim[3];
    memset(&__delim,0,3);
    switch(__gtype){
        case __key_value:
            __delim[0]=ATP_KV_SEP;
            __delim[1]='\0';
            return strdup(__delim);
        case __env_variable:
            __delim[0]=ATP_ENV_SEP;
            __delim[1]='\0';
            return strdup(__delim);
        case __sock_address:
            __delim[0]=ATP_KV_SEP;
            __delim[1]=ATP_ENV_SEP;
            break;
        case __description:
            __delim[0]=ATP_ENV_SEP;
            __delim[1]=ATP_KV_SEP;
            break;
        default:break;
    }
    __delim[2]='\0';
    #ifdef DEBUG
        printf("delimiter is '%s'\n",__delim);
    #endif
    return strdup(__delim);
};

char *__generic_fmt(__gev g_type,char *__key, char *__value){
    ulong klen=strlen(__key);
    ulong vlen=strlen(__value);
    ulong clen=klen+vlen+2;

    // log_gfmt(g_type);
    // log_keyvalue(__key,__value);

    char lbb_field[clen];
    memset(&lbb_field,0,clen);
    lbb_field[clen]='\0';
    memmove(lbb_field,__key,klen);
    char const *_delim=__gdelim(g_type);
    ulong __dlen=strlen(_delim);
    memmove((lbb_field+klen),_delim, __dlen);
    memmove((lbb_field+klen+__dlen),__value,vlen);

    #ifdef LBB_PRINT
        __ASCII(lbb_field)
    #endif
    #ifdef DEBUG
        printf("{%s}",lbb_field);
    #endif
    return strdup(lbb_field);
};


// __TEXT(Hello World); //valid in ATP
#ifdef __AT_PROTOCOL__
int main(int argc, char **argv) {
    spec var;
    spec_set_type(&var, KV);
    OUT_ASCII(0,var.g_delim);
    return 0;
}
#endif
































