/// IXR \\\
the indexer

#ifndef __IXR__H
#include "ixr.h"
#endif

#define DEBUG 1

#ifndef __ixr_name
	#define __ixr_name "indexer"
static const char *__ixr_frame="@charms/.lbb";
static const char *IXR_KV_FMT="K:V";
static const char *__KVFMT="%lx@%s\n";
static const char *IXR_KVP_FMT="%s=P";
static const char *IXR_KVPS_FMT="%s:=S";
static const char *IXR_KVPSD_FMT="%s=:D";


#define LONG_SIZE ULONG_SIZE
#define ULONG_SIZE ((ulong)(sizeof(ulong)))
#define uc_size(x) ((ulong)(x*sizeof(uchar)))

static frindex flyIndex;
static ulong ___offset=0;



ulong _fsize(char const *__fpath){
    struct stat __;
    memset(&__,0,sizeof(struct stat));
    if(stat(__fpath,&__)!=0){return 0;}
    return __.st_size;
};

ulong _inodenum(char const *__fpath){
	struct stat __;
	memset(&__,0,sizeof(struct stat));
	if(stat(__fpath,&__)!=0){return 0;}
	return __.st_ino;
};

int _stres(char const *__fpath){
	return access(__fpath,F_OK)==0;
};




	ulong __index_increment() {
		__cindex+=1;
		return __cindex;
	};

	ulong __set_next(char *__head){
		ulong __len=strlen(__head);
		long _res=write(__ixr_fd,__head,__len);
		if(_res!=-1){
			___offset+=__len;
		}
		#ifdef DEBUG
			printf("SET{ NEXT }\n");
			printf("head   :: %s\n", __head);
			printf("length :: %lu\n", __len);
			printf("result :: %ld\n", _res);
			printf("offset ::: %lu\n", ___offset);
		#endif
		return (ulong)_res;
	};

	ulong indexer_start(char const *idxr){
		if(__cindex!=0){
			return 0;
		};
		#ifndef INDEXER
			#define INDEXER __cindex;
		#endif

		return __index_increment();
	};

	void __include_frame(frindex *idx) {
		char __[512];
		memset(&__,0,sizeof(__));
		sprintf(__,"%lu:kR%s:%s",idx->__fridx,idx->__fref,idx->__frname);
		__set_next(__);
	};

	int __define_frame() {
		frindex __;
		memset(&__,0,sizeof(frindex));

		ulong frame_inn=__.__fridx, *fr_inn=&frame_inn;
		frame_inn=_inodenum(__ixr_frame);
		#ifdef DEBUG
			printf("frame ::\n");
			printf(" inodenum =%lu \n",frame_inn);
			printf(" cindex   =%lu \n",__cindex);
		#endif
		__.__fref=hashof(0,fr_inn,ULONG_SIZE);
		__.__frname="seed";
		__include_frame(&__);
		return 0;
	};

	int on_the_fly(frindex *ptrx, int otf_t, char const *sha_val, ulong indx){


		return 0;
	}

	frindex *get_fridx(ulong x_offset){
		char otf_buf[512], otfp=*otf_buf;
		memset(&otf_buf,0,sizeof(otf_buf));

		ulong c=0,_count=0,_len=0,__FLAG=0;
		while(!__FLAG) {
			__FLAG=1;
			c=pread(__ixr_fd, (otf_buf+_len), 8, x_offset);
			while((otfp=*(otf_buf+_count))!='\n'){
				if(_count==c){
					__FLAG=0;
					break;
				};
				_count+=1;
			};
			_count=0;
			_len+=c;
		};
		memset(&flyIndex,0,sizeof(frindex));

		ulong *fi_index;
		char fi_ref[64],fi_name[64];
		memset(fi_ref,0,sizeof(fi_ref));
		memset(fi_name,0,sizeof(fi_name));
		sscanf(otf_buf,"%lu:%s:%s",fi_index,fi_ref,fi_name);

		flyIndex.__fridx=*fi_index;
		flyIndex.__fref=fi_ref;
		flyIndex.__frname=fi_name;
		return &flyIndex;
	};


	char *__traverse_frame() {
		char __[512];
		memset(&__,0,sizeof(__));
		int res=pread(__ixr_fd,__,512,___offset);
		if(res==-1){
			return NULL;
		};
		return strdup(__);
	};

	int _trav_index(ulong _idx) {
		return 0;
	}


	int __add_to_indexer(frindex *fidx) {


		return __cindex;
	}




	int __open_frame() {
		int ixr_fd=-1;
		if(!_stres(__ixr_frame)){
			#ifdef DEBUG
				printf("init indexer\n");
			#endif
			ixr_fd=open(__ixr_frame,(O_RDWR|O_APPEND|O_CREAT|O_EXCL|O_NOFOLLOW_ANY),(S_IRWXU|S_IXGRP|S_IXOTH));
			__ixr_fd=(ulong)ixr_fd;
			__define_frame();
			return 1;
		}
		else{
			#ifdef DEBUG
				printf("opening indexer\n");
			#endif
			ixr_fd=open(__ixr_frame,(O_RDWR|O_NOFOLLOW_ANY),(S_IRWXU|S_IXGRP|S_IXOTH));
		};
		#ifdef DEBUG
			printf("file descriptor :open::%d\n",ixr_fd);
		#endif
		if(ixr_fd==-1){
			printf("Cannot instantiate indexer\n");
			return -1;
		};
		__ixr_fd=(ulong)ixr_fd;
		return 2;
	}

	ulong __indexer__(char const *idxnr) {
		switch(__open_frame()){
		case 1:
			break;
			printf("\nCASE {1}::\n");
			// started a new frame with `define_frame`
			#ifdef DEBUG
				printf("indexer field :%s::%lu\n",idxnr,__cindex);
				printf("cindex=%lu\n",__cindex);
				// OUT_ASCII(__ixr_fd,idxnr);
			#endif
			return __cindex;
		case -1:
			printf("\nCASE {-1}::\n");
			//file descriptor is zero, cannot be opened or initiated
			#ifdef DEBUG
				printf("indexer field :%s::%lu\n",idxnr,__cindex);
				printf("cindex=%lu\n",__cindex);
				// OUT_ASCII(__ixr_fd,idxnr);
			#endif
			return 0;
		case 2:
			printf("\nCASE {2}::\n");
			// using a previously existing frame
			#ifdef DEBUG
				printf("indexer field :%s::%lu\n",idxnr,__cindex);
				printf("cindex=%lu\n",__cindex);
				// OUT_ASCII(__ixr_fd,idxnr);
			#endif
			return indexer_start(idxnr);;
		default:
			break;
		}
		printf("\nCASE {default}::%lu\n",__cindex);
		return __cindex;
	};

	ulong __get_xron(char const *__shav){
		frindex ixron;
		memset(&ixron,0,sizeof(frindex));
		int res=on_the_fly(&ixron, 2, __shav, 0);
		if(res==-1){
			return 0;
		};
		return ixron.__fridx;
	}

	char const *__get_ixron(ulong __inn){
		frindex ixron;
		memset(&ixron,0,sizeof(frindex));
		int res=on_the_fly(&ixron, 1, NULL, __inn);
		if(res==-1){
			return NULL;
		};
		return (char const *)ixron.__fref;
	};

	int __set_comp(char *__eof_seq){
		ulong eslen=strlen(__eof_seq);ulong esqlen=eslen+2;
		char __[esqlen];
		memset(&__,0,esqlen);
		memmove(__,__eof_seq,eslen);
		memmove((__+eslen),"\0",2);
		// ulong res=__set_next(__);
		close(__ixr_fd);
		return 0;
	};

	char const *__index(char *__) {
		ulong llen=__set_next(__);
		return hashof(1,(void *)IDXR,LONG_SIZE);
	};



































	void log_gfmt(__gev g_type) {
		switch(g_type) {
		case __key_value: __TEXT(Key:Value); break;
		case __env_variable: __TEXT(Enviroment=Spec); break;
		case __sock_address: __TEXT(Socket:=Address); break;
		case __description: __TEXT(Description=:Callable); break;
		default: __TEXT(Unknown); break;
		};
	};

	void log_keyvalue(char *key, char *value) {
		__ASCII(key);
		__ASCII(value);
	};



#endif


















