/// lenk \\\
left-to-right encoding num(k)


#ifndef __enk_name
    #define __enk_name "encoding_number_k"
    #include "probe.h"

    #define packi16 pack_i_16
    #define packi32 pack_i_32
    #define packi64 pack_i_64

    #define unpacki16 unpack_i_16
    #define unpacku16 unpack_u_16

    #define unpacki32 unpack_i_32
    #define unpacku32 unpack_u_32

    #define unpacki64 unpack_i_64
    #define unpacku64 unpack_u_64

    #define pack754_16( f ) ( pack754( ( f ) , 16 , 4 ) )
    #define pack754_32( f ) ( pack754( ( f ) , 32 , 8 ) )
    #define pack754_64( f ) ( pack754( ( f ) , 64 , 11 ) )

    #define unpack754_16( i ) ( unpack754( ( i ) , 16 , 4 ) )
    #define unpack754_32( i ) ( unpack754( ( i ) , 32 , 8 ) )
    #define unpack754_64( i ) ( unpack754( ( i ) , 64 , 11 ) )

    // 16 bit integer
    #define packu16(ubuf,num) (enc_unum(1,ubuf,num))
    void pack_i_16( unsigned char *buf , unsigned int i ) {

    	*buf++ = i >> 8; *buf++ = i;
    }
    // 32 bit integer
    #define packu32(ubuf,num) (enc_unum(3,ubuf,num))
    void pack_i_32( unsigned char *buf , unsigned long int i ) {

    	*buf++ = i>>24;	*buf++ = i>>16;
    	*buf++ = i>>8;	*buf++ = i;
    }
    // 64 bit integer
    #define packu64(ubuf,num) (enc_unum(7,ubuf,num))
    void pack_i_64( unsigned char *buf , unsigned long long int i ) {
    	*buf++ = i>>56;	*buf++ = i>>48;
    	*buf++ = i>>40;	*buf++ = i>>32;
    	*buf++ = i>>24; *buf++ = i>>16;
    	*buf++ = i>>8;  *buf++ = i;	
    }

    void enc_unum( ulong base , uchar *buf , ulong i ) {
        while ( base > 0 ) {
            *buf++ = i >> (8*base);
            base--; 
        }
        *buf++ = i;
    }

    void enc_brnum( ulong base , ulong roof , uchar *buf , ulong *i ) {
        for(ulong iter=0; roof-iter>0; iter++){
            while ( base > 0 ) {
                *buf++ = i[iter] >> (8*base);
                base--;
            }
            *buf++= i[iter];
        }
    }

    void pack_i_128( unsigned char *buf , unsigned long long int x[2] ) {
        *buf++ = x[0]>>56 ; *buf++ = x[0]>>48;
        *buf++ = x[0]>>40 ; *buf++ = x[0]>>32;
        *buf++ = x[0]>>24  ; *buf++ = x[0]>>16;
        *buf++ = x[0]>>8  ; *buf++ = x[0]; 
        *buf++ = x[1]>>56  ; *buf++ = x[1]>>48;
        *buf++ = x[1]>>40  ; *buf++ = x[1]>>32;
        *buf++ = x[1]>>24  ; *buf++ = x[1]>>16;
        *buf++ = x[1]>>8   ; *buf++ = x[1]; 
    }

    // floating nums
    uint64_t pack754( long double f , unsigned bits , unsigned expbits ) {
        long double fnorm;
        int shift;
        long long sign, exp, significand;
        unsigned significandbits = bits - expbits - 1; // -1 for sign bit

        if (f == 0.0) return 0; // get this special case out of the way

        // check sign and begin normalization
        if (f < 0) { sign = 1; fnorm = -f; }
        else { sign = 0; fnorm = f; }

        // get the normalized form of f and track the exponent
        shift = 0;
        while(fnorm >= 2.0) { fnorm /= 2.0; shift++; }
        while(fnorm < 1.0) { fnorm *= 2.0; shift--; }
        fnorm = fnorm - 1.0;

        // calculate the binary form (non-float) of the significand data
        significand = fnorm * ((1LL<<significandbits) + 0.5f);

        // get the biased exponent
        exp = shift + ((1<<(expbits-1)) - 1); // shift + bias

        // return the final answer
        return (sign<<(bits-1)) | (exp<<(bits-expbits-1)) | significand;
    }
    /*
    pack() -- store data dictated by the format string in the buffer
        **
        **   bits |signed   unsigned   float   string
        **   -----+----------------------------------
        **      8 |   c        C         
        **     16 |   h        H         f
        **     32 |   l        L         d
        **     64 |   q        Q         g
        **      - |                               s
        **
        **  (16-bit unsigned length is automatically prepended to strings)
    */ 
    unsigned int pack( unsigned char *buf , char const*format , ... ) {
        va_list ap;

        signed char c;              // 8-bit
        unsigned char C;

        int h;                      // 16-bit
        unsigned int H;

        long int l;                 // 32-bit
        unsigned long int L;

        long long int q;            // 64-bit
        unsigned long long int Q;

        float f;                    // floats
        double d;
        long double g;
        unsigned long long int fhold;

        char *s;                    // strings
        unsigned int len;

        unsigned int size = 0;

        va_start(ap, format);

        for(; *format != '\0'; format++) {
            switch(*format) {
            case 'c': // 8-bit
                size += 1;
                c = (signed char)va_arg(ap, int); // promoted
                *buf++ = c;
                break;

            case 'C': // 8-bit unsigned
                size += 1;
                C = (unsigned char)va_arg(ap, unsigned int); // promoted
                *buf++ = C;
                break;

            case 'h': // 16-bit
                size += 2;
                h = va_arg(ap, int);
                packi16(buf, h);
                buf += 2;
                break;

            case 'H': // 16-bit unsigned
                size += 2;
                H = va_arg(ap, unsigned int);
                packi16(buf, H);
                buf += 2;
                break;

            case 'l': // 32-bit
                size += 4;
                l = va_arg(ap, long int);
                packi32(buf, l);
                buf += 4;
                break;

            case 'L': // 32-bit unsigned
                size += 4;
                L = va_arg(ap, unsigned long int);
                packu32(buf, L);
                buf += 4;
                break;

            case 'q': // 64-bit
                size += 8;
                q = va_arg(ap, long long int);
                packi64(buf, q);
                buf += 8;
                break;

            case 'Q': // 64-bit unsigned
                size += 8;
                Q = va_arg(ap, unsigned long long int);
                packu64(buf, Q);
                buf += 8;
                break;

            case 'f': // float-16
                size += 2;
                f = (float)va_arg(ap, double); // promoted
                fhold = pack754_16(f); // convert to IEEE 754
                packi16(buf, fhold);
                buf += 2;
                break;

            case 'd': // float-32
                size += 4;
                d = va_arg(ap, double);
                fhold = pack754_32(d); // convert to IEEE 754
                packi32(buf, fhold);
                buf += 4;
                break;

            case 'g': // float-64
                size += 8;
                g = va_arg(ap, long double);
                fhold = pack754_64(g); // convert to IEEE 754
                packi64(buf, fhold);
                buf += 8;
                break;

            case 's': // string
                s = va_arg(ap, char*);
                len = strlen(s);
                size += len + 2;
                packi16(buf, len);
                buf += 2;
                memcpy(buf, s, len);
                buf += len;
                break;
            }
        }

        va_end(ap);

        return size;
    }

    /********************************************************************
    *********************************************************************/

    // 16 bit SIGNED
    int unpack_i_16( unsigned char *buf ) {
    	unsigned int i2 = ( ( unsigned int )buf[0]<<8 )| buf[1];
    	int i;

    	if ( i2 <= 0x7fffu ) { i = i2; }
    	else { i = -1 - ( unsigned int )( 0xffffu - i2 ); }

    	return i;
    }
    // 16 bit UNSIGNED 
    unsigned int unpack_u_16( unsigned char *buf ) {
    	return ( ( unsigned int )buf[0]<<8 )| buf[1]; 
    }
    // 32 bit SIGNED
    long int unpack_i_32( unsigned char *buf ) {
    	unsigned long int i2 =  ( ( unsigned long int )buf[0]<<24 ) | 
    							( ( unsigned long int )buf[1]<<16 ) |
    							( ( unsigned long int )buf[2]<<8 )	|
    							buf[3];
    	long int i;

    	if ( i2 <= 0x7fffffffu ) { i = i2; }
    	else { i = -1 - ( long int )( 0xffffffffu - i2 ); }

    	return i;
    }
    // 32 bit UNSIGNED
    unsigned long int unpack_u_32( unsigned char *buf ) {
    	return \
    		( ( unsigned long int )buf[0]<<24 ) | 
    		( ( unsigned long int )buf[1]<<16 ) |
    		( ( unsigned long int )buf[2]<<8 )	|
    		buf[3];
    }
    // 64 bit SIGNED 
    long long int unpack_i_64( unsigned char *buf ) {
    	unsigned long long int i2 = 
    		( ( unsigned long long int )buf[0]<<56 ) |
    		( ( unsigned long long int )buf[1]<<48 ) |
    		( ( unsigned long long int )buf[2]<<40 ) |
    		( ( unsigned long long int )buf[3]<<32 ) |
    		( ( unsigned long long int )buf[4]<<24 ) |
    		( ( unsigned long long int )buf[5]<<16 ) |
    		( ( unsigned long long int )buf[6]<<8 )	 |
    		buf[7];

    	long long int i;

    	if ( i2 <= 0x7fffffffffffffffu ) { i = i2; }
    	else { i = -1 - ( long long int )( 0xffffffffffffffffu - i2 ); }

    	return i;
    }
    // 64 bit UNSIGNED
    unsigned long long int unpack_u_64( unsigned char *buf ) {
    	return \
    		( ( unsigned long long int )buf[0]<<56 ) |
    		( ( unsigned long long int )buf[1]<<48 ) |
    		( ( unsigned long long int )buf[2]<<40 ) |
    		( ( unsigned long long int )buf[3]<<32 ) |
    		( ( unsigned long long int )buf[4]<<24 ) |
    		( ( unsigned long long int )buf[5]<<16 ) |
    		( ( unsigned long long int )buf[6]<<8 )	 |
    		buf[7];
    }
    // floating nums
    long double unpack754( uint64_t i , unsigned bits , unsigned expbits ) {
        long double result;
        long long shift;
        unsigned bias;
        unsigned significandbits = bits - expbits - 1; // -1 for sign bit

        if (i == 0) return 0.0;

        // pull the significand
        result = (i&((1LL<<significandbits)-1)); // mask
        result /= (1LL<<significandbits); // convert back to float
        result += 1.0f; // add the one back on

        // deal with the exponent
        bias = (1<<(expbits-1)) - 1;
        shift = ((i>>significandbits)&((1LL<<expbits)-1)) - bias;
        while(shift > 0) { result *= 2.0; shift--; }
        while(shift < 0) { result /= 2.0; shift++; }

        // sign it
        result *= (i>>(bits-1))&1? -1.0: 1.0;

        return result;
    }
    /*
    unpack() -- unpack data dictated by the format string into the buffer
        **
        **   bits |signed   unsigned   float   string
        **   -----+----------------------------------
        **      8 |   c        C         
        **     16 |   h        H         f
        **     32 |   l        L         d
        **     64 |   q        Q         g
        **      - |                               s
        **
        **  (string is extracted based on its stored length, but 's' can be
        **  prepended with a max length)
    */
    void unpack( unsigned char *buf , char const*format , ... ) {
        va_list ap;

        signed char *c;              // 8-bit
        unsigned char *C;

        int *h;                      // 16-bit
        unsigned int *H;

        long int *l;                 // 32-bit
        unsigned long int *L;

        long long int *q;            // 64-bit
        unsigned long long int *Q;

        float *f;                    // floats
        double *d;
        long double *g;
        unsigned long long int fhold;

        char *s;
        unsigned int len, maxstrlen=0, count;

        va_start(ap, format);

        for(; *format != '\0'; format++) {
            switch(*format) {
            case 'c': // 8-bit
                c = va_arg(ap, signed char*);
                if (*buf <= 0x7f) { *c = *buf;} // re-sign
                else { *c = -1 - (unsigned char)(0xffu - *buf); }
                buf++;
                break;

            case 'C': // 8-bit unsigned
                C = va_arg(ap, unsigned char*);
                *C = *buf++;
                break;

            case 'h': // 16-bit
                h = va_arg(ap, int*);
                *h = unpacki16(buf);
                buf += 2;
                break;

            case 'H': // 16-bit unsigned
                H = va_arg(ap, unsigned int*);
                *H = unpacku16(buf);
                buf += 2;
                break;

            case 'l': // 32-bit
                l = va_arg(ap, long int*);
                *l = unpacki32(buf);
                buf += 4;
                break;

            case 'L': // 32-bit unsigned
                L = va_arg(ap, unsigned long int*);
                *L = unpacku32(buf);
                buf += 4;
                break;

            case 'q': // 64-bit
                q = va_arg(ap, long long int*);
                *q = unpacki64(buf);
                buf += 8;
                break;

            case 'Q': // 64-bit unsigned
                Q = va_arg(ap, unsigned long long int*);
                *Q = unpacku64(buf);
                buf += 8;
                break;

            case 'f': // float
                f = va_arg(ap, float*);
                fhold = unpacku16(buf);
                *f = unpack754_16(fhold);
                buf += 2;
                break;

            case 'd': // float-32
                d = va_arg(ap, double*);
                fhold = unpacku32(buf);
                *d = unpack754_32(fhold);
                buf += 4;
                break;

            case 'g': // float-64
                g = va_arg(ap, long double*);
                fhold = unpacku64(buf);
                *g = unpack754_64(fhold);
                buf += 8;
                break;

            case 's': // string
                s = va_arg(ap, char*);
                len = unpacku16(buf);
                buf += 2;
                if (maxstrlen > 0 && len >= maxstrlen) count = maxstrlen - 1;
                else count = len;
                memcpy(s, buf, count);
                s[count] = '\0';
                buf += len;
                break;

            default:
                if (isdigit(*format)) { // track max str len
                    maxstrlen = maxstrlen * 10 + (*format-'0');
                }
            }

            if (!isdigit(*format)) maxstrlen = 0;
        }

        va_end(ap);
    }

    int sendall( int s , char *buf , int *len ) {
        int total = 0;        // how many bytes we've sent
        int bytesleft = *len; // how many we have left to send
        int n;
        while( total < *len ) {
            n = send( s , buf+total , bytesleft , 0 );
            if ( n == -1 ) { break; }
            total += n;
            bytesleft -= n;
        }
        *len = total; // return number actually sent here
        return n==-1?-1:0; // return -1 on failure, 0 on success
    }
#endif