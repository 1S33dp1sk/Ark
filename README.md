# ather


## a *point*

## t *to*

## h *hbar*

## e *entry*

## r *lbb*

Let me run you through the reason, distributed systems and decentralization are very important. 

During the development of centralized systems such as the ones we see today, there has been massive improvments in speed and efficency due to an **increase** in demand from the sectors revolving around *centralized* applications, such as :    

1.  search engines
2.  social media and application specific targeting
3.  games
4.  data-sharing, dropbox - googledrive - ... 

However, most of the current software that is written; is optimized to run on a single core handling a large amount of users because that is what we are acustom to and that is the norm. However, it should be noted, that a lot of different application is much better and more effecient in a decetralized world, and others are much better in a distributed system and finally others are as good as it currently is using centralization.

Furthermore, if we consider the eagle view of such systems, we can speculate that if we have an *improvment function* `I( x , theta )` that applies on a certain input **x** and that varies with time **theta** hit a "local" threshold, in normal technological terms, the amount of improvments based on the current level of technology in it's sole spectrum is not as profitable as trying to decrease **x** to `s( x_les )` where a different *improvment function* can be applied on 

`s` to yeild :: 
	`I_1( I_2( x_les , theta_les ) , theta )`


&& *profitable* here is in terms of opportinuity cost.


essentially the internet and the networks in general are like an ant colony and each user is essentially an ant, what we are aiming to do is not create 
a better colony, but rather, create better ants.



each athering device MUST have a singular `atherpoint`.




with little to none in other broad areas such as decentralization && distributed systems which if explored can yeild a more effecient system. 



<<<<<<< HEAD
<<<<<<< HEAD

/**
 * each athering device MUST
 * have a singular `atherpoint`
 */
=======
each athering device MUST have a singular `atherpoint`.

*******************************
async-safe defined in POSIX ::

=======
*******************************
async-safe defined in POSIX ::

>>>>>>> anet_V9/athernet
 *      _Exit(), 
 *      _exit(), 
 *      abort(), 
 *      accept(), 
 *      access(), 
 *      aio_error(), 
 *      aio_return(), 
 *      aio_suspend(), 
 *      alarm(), 
 *      bind(), 
 *      cfgetispeed(), 
 *      cfgetospeed(), 
 *      cfsetispeed(), 
 *      cfsetospeed(), 
 *      chdir(), 
 *      chmod(), 
 *      chown(), 
 *      clock_gettime(), 
 *      close(), 
 *      connect(), 
 *      creat(), 
 *      dup(), 
 *      dup2(), 
 *      execle(), 
 *      execve(), 
 *      fchmod(), 
 *      fchown(), 
 *      fcntl(), 
 *      fdatasync(), 
 *      fork(), 
 *      fpathconf(), 
 *      fstat(),
 *      fsync(), 
 *      ftruncate(), 
 *      getegid(), 
 *      geteuid(), 
 *      getgid(), 
 *      getgroups(), 
 *      getpeername(), 
 *      getpgrp(), 
 *      getpid(), 
 *      getppid(), 
 *      getsockname(), 
 *      getsockopt(), 
 *      getuid(), 
 *      kill(), 
 *      link(), 
 *      listen(), 
 *      lseek(), 
 *      lstat(), 
 *      mkdir(), 
 *      mkfifo(),
 *      open(), 
 *      pathconf(), 
 *      pause(), 
 *      pipe(), 
 *      poll(), 
 *      posix_trace_event(), 
 *      pselect(), 
 *      raise(), 
 *      read(), 
 *      readlink(), 
 *      recv(), 
 *      recvfrom(), 
 *      recvmsg(), 
 *      rename(), 
 *      rmdir(), 
 *      select(), 
 *      sem_post(), 
 *      send(), 
 *      sendmsg(), 
 *      sendto(), 
 *      setgid(), 
 *      setpgid(), 
 *      setsid(), 
 *      setsockopt(), 
 *      setuid(), 
 *      shutdown(), 
 *      sigaction(), 
 *      sigaddset(), 
 *      sigdelset(), 
 *      sigemptyset(), 
 *      sigfillset(), 
 *      sigismember(), 
 *      sleep(), 
 *      signal(), 
 *      sigpause(), 
 *      sigpending(), 
 *      sigprocmask(), 
 *      sigqueue(), 
 *      sigset(), 
 *      sigsuspend(), 
 *      sockatmark(), 
 *      socket(), 
 *      socketpair(), 
 *      stat(), 
 *      symlink(), 
 *      sysconf(), 
 *      tcdrain(), 
 *      tcflow(), 
 *      tcflush(), 
 *      tcgetattr(), 
 *      tcgetpgrp(), 
 *      tcsendbreak(), 
 *      tcsetattr(), 
 *      tcsetpgrp(), 
 *      time(), 
 *      timer_getoverrun(), 
 *      uname(), 
 *      timer_gettime(), 
 *      timer_settime(), 
 *      times(), 
 *      umask(), 
 *      unlink(), 
 *      utime(), 
 *      wait(), 
 *      waitpid(), 
 *      write()
*******************************
<<<<<<< HEAD
>>>>>>> in_vik/main
=======
>>>>>>> anet_V9/athernet
