# ather


## at *point*

## h *hbar*

## e *entry*

## r *lbb*

Let me run you through the reason, distributed systems and decentralization are very important. During the development of centralized systems such as the ones we see today, there has been massive improvments in the sectors revolving around that, with little to none in other broad areas that if explored can sum up to a more effecient process. 

Furthermore, if we consider the grand scheme of things, we can speculate that if we have an *improvment function* `I( x , theta )` that applies on a certain input **x** and that varies with time **theta** hit a "local" threshold, in normal technological terms, the amount of improvments based on the current level of technology in it's sole spectrum is not as profitable as trying to decrease **x** to `s( x_les )` where a different *improvment function* can be applied on 

`s` to yeild :: 
	`I_1( I_2( x_les , theta_les ) , theta )`


&& *profitable* here is in terms of opportinuity cost.


** insert richard hendrix quote about ants **

<<<<<<< HEAD

/**
 * each athering device MUST
 * have a singular `atherpoint`
 */
=======
each athering device MUST have a singular `atherpoint`.

*******************************
async-safe defined in POSIX ::

 *      _Exit(), 
 *      _exit(), 
 *      abort(), 
 *      accept(), 
 *      access(), 
 *      aio_error(), 
 *      aio_return(), 
 *      aio_suspend(), 
 *      alarm(), 
 *      bind(), 
 *      cfgetispeed(), 
 *      cfgetospeed(), 
 *      cfsetispeed(), 
 *      cfsetospeed(), 
 *      chdir(), 
 *      chmod(), 
 *      chown(), 
 *      clock_gettime(), 
 *      close(), 
 *      connect(), 
 *      creat(), 
 *      dup(), 
 *      dup2(), 
 *      execle(), 
 *      execve(), 
 *      fchmod(), 
 *      fchown(), 
 *      fcntl(), 
 *      fdatasync(), 
 *      fork(), 
 *      fpathconf(), 
 *      fstat(),
 *      fsync(), 
 *      ftruncate(), 
 *      getegid(), 
 *      geteuid(), 
 *      getgid(), 
 *      getgroups(), 
 *      getpeername(), 
 *      getpgrp(), 
 *      getpid(), 
 *      getppid(), 
 *      getsockname(), 
 *      getsockopt(), 
 *      getuid(), 
 *      kill(), 
 *      link(), 
 *      listen(), 
 *      lseek(), 
 *      lstat(), 
 *      mkdir(), 
 *      mkfifo(),
 *      open(), 
 *      pathconf(), 
 *      pause(), 
 *      pipe(), 
 *      poll(), 
 *      posix_trace_event(), 
 *      pselect(), 
 *      raise(), 
 *      read(), 
 *      readlink(), 
 *      recv(), 
 *      recvfrom(), 
 *      recvmsg(), 
 *      rename(), 
 *      rmdir(), 
 *      select(), 
 *      sem_post(), 
 *      send(), 
 *      sendmsg(), 
 *      sendto(), 
 *      setgid(), 
 *      setpgid(), 
 *      setsid(), 
 *      setsockopt(), 
 *      setuid(), 
 *      shutdown(), 
 *      sigaction(), 
 *      sigaddset(), 
 *      sigdelset(), 
 *      sigemptyset(), 
 *      sigfillset(), 
 *      sigismember(), 
 *      sleep(), 
 *      signal(), 
 *      sigpause(), 
 *      sigpending(), 
 *      sigprocmask(), 
 *      sigqueue(), 
 *      sigset(), 
 *      sigsuspend(), 
 *      sockatmark(), 
 *      socket(), 
 *      socketpair(), 
 *      stat(), 
 *      symlink(), 
 *      sysconf(), 
 *      tcdrain(), 
 *      tcflow(), 
 *      tcflush(), 
 *      tcgetattr(), 
 *      tcgetpgrp(), 
 *      tcsendbreak(), 
 *      tcsetattr(), 
 *      tcsetpgrp(), 
 *      time(), 
 *      timer_getoverrun(), 
 *      uname(), 
 *      timer_gettime(), 
 *      timer_settime(), 
 *      times(), 
 *      umask(), 
 *      unlink(), 
 *      utime(), 
 *      wait(), 
 *      waitpid(), 
 *      write()
*******************************
>>>>>>> in_vik/main
